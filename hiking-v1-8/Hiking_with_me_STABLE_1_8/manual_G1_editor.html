<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8" />
<title>è·¯çº¿äººå·¥ç¼–è¾‘å™¨ï¼ˆG1 åœ°å½¢ + åœºæ™¯èŠ‚ç‚¹ + å¤©æ°”å¢å¼ºç‰ˆï¼‰</title>

<!-- Leaflet åœ°å›¾æ ·å¼ä¸è„šæœ¬ -->
<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

<style>
body {
  font-family: Arial, sans-serif;
  padding: 10px 20px 40px;
  background: #f5f5f5;
}
h1 {
  margin-bottom: 10px;
}
.box {
  background: white;
  padding: 16px;
  border-radius: 10px;
  border: 1px solid #ddd;
  margin-bottom: 16px;
}
.top-bar {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  align-items: center;
  margin-bottom: 10px;
}
.top-bar input[type="file"] {
  max-width: 260px;
}
button {
  padding: 6px 12px;
  background: #007bff;
  color: white;
  border-radius: 6px;
  border: none;
  cursor: pointer;
  font-size: 13px;
}
button:hover { background: #005fcc; }
button.secondary { background: #6c757d; }
button.secondary:hover { background: #5a6268; }
button.danger { background: #d9534f; }
button.danger:hover { background: #c9302c; }
button.success { background: #28a745; }
button.success:hover { background: #218838; }

#loadStatus { margin-left: 8px; }

/* Tabs */
.tab-header {
  display: flex;
  border-bottom: 2px solid #007bff33;
  margin-bottom: 10px;
}
.tab-header button {
  padding: 10px 18px;
  border-radius: 6px 6px 0 0;
  background: #e9ecef;
  border: none;
  margin-right: 6px;
  font-weight: bold;
  color: #333;
}
.tab-header button.active {
  background: #ffffff;
  border-bottom: 2px solid #007bff;
  color: #007bff;      /* â˜… ä¿®å¤ Tab å­—ä½“çœ‹ä¸è§ */
}

.tab-content { display: none; }
.tab-content.active { display: block; }

/* Table */
table {
  width: 100%;
  border-collapse: collapse;
  background: white;
  font-size: 13px;
}
th, td {
  border: 1px solid #ccc;
  padding: 6px;
  text-align: left;
  vertical-align: top;
}
th {
  background: #eee;
}
input[type="text"], textarea, input[type="number"] {
  width: 100%;
  padding: 4px;
  border: 1px solid #bbb;
  border-radius: 4px;
  box-sizing: border-box;
}
textarea {
  resize: vertical;
}

/* åœ°å›¾å¼¹çª— */
#mapModal {
  display: none;
  position: fixed;
  z-index: 9999;
  left: 0; top: 0; right: 0; bottom: 0;
  background: rgba(0,0,0,0.55);
  backdrop-filter: blur(2px);
}
#mapContainer {
  width: 80%;
  height: 80%;
  margin: 4% auto;
  background: white;
  border-radius: 8px;
  position: relative;
  overflow: visible;   /* â˜… å…³é”®ä¿®å¤ï¼šä¸å†è£å‰ª Leaflet */
  box-shadow: 0 0 20px rgba(0,0,0,0.3);
}
#mapToolbar {
  position: absolute;
  z-index: 10000;
  left: 0; right: 0;
  background: white;
  padding: 6px;
  border-bottom: 1px solid #ccc;
  display: flex;
  gap: 8px;
  align-items: center;
}
#mapToolbar select,
#mapToolbar input[type="text"] {
  padding: 4px;
  border: 1px solid #ccc;
  border-radius: 4px;
}
#map {
  position: absolute;
  top: 42px;            /* â˜… toolbar é«˜åº¦ */
  left: 0;
  right: 0;
  bottom: 0;
}

</style>
</head>

<body>
<h1>è·¯çº¿äººå·¥å½•å…¥ç¼–è¾‘å™¨ï¼ˆG1 åœ°å½¢ + åœºæ™¯èŠ‚ç‚¹ + å¤©æ°”å¢å¼ºç‰ˆï¼‰</h1>

<!-- é¡¶éƒ¨æ“ä½œæ  -->
<div class="box">
  <div class="top-bar">
    <input type="file" id="jsonInput" accept=".json">
    <button onclick="loadJSON()">åŠ è½½ JSON</button>

    <button class="success" onclick="saveDraft()">ä¿å­˜è‰ç¨¿</button>
    <button class="secondary" onclick="clearDraft()">æ¸…é™¤è‰ç¨¿</button>

    <!-- â­ åªä¿ç•™ä¸€ä¸ªç”ŸæˆèŠ‚ç‚¹è¡¨æŒ‰é’® -->
    <button onclick="exportNodeModel()">ç”ŸæˆèŠ‚ç‚¹è¡¨ï¼ˆNode Model JSONï¼‰</button>

    <span id="loadStatus"></span>
  </div>
</div>

<!-- â˜… ä¸‰ä¸ª Tabï¼šäººå·¥ â†’ å¤©æ°” â†’ åœ°å½¢ -->
<div class="tab-header">
  <button id="tabBtnScenes" class="active" onclick="switchTab('scenes')">äººå·¥èŠ‚ç‚¹</button>
  <button id="tabBtnWeather" onclick="switchTab('weather')">å¤©æ°”èŠ‚ç‚¹</button>
  <button id="tabBtnSegments" onclick="switchTab('segments')">åœ°å½¢èŠ‚ç‚¹</button>
</div>

<!-- TAB â‘ ï¼šäººå·¥èŠ‚ç‚¹ï¼ˆé»˜è®¤ï¼‰ -->
<div id="tabScenes" class="tab-content active">
  <h3>äººå·¥åœºæ™¯èŠ‚ç‚¹ï¼ˆæ‰‹å·¥ç»´æŠ¤ï¼Œå¯åœ°å›¾æ‹¾å–åæ ‡ï¼‰</h3>
  <button onclick="addManualScene()">æ–°å¢èŠ‚ç‚¹</button>
  <br><br>

  <table>
    <thead>
      <tr>
        <th>#</th>
        <th>ç±»åˆ«</th>
        <th>æ ‡é¢˜ï¼ˆç®€ç§°ï¼‰</th>
        <th>å‰¯æ ‡é¢˜ï¼ˆæè¿°ï¼‰</th>
        <th>é‡Œç¨‹åŒºé—´</th>
        <th>æµ·æ‹”åŒºé—´</th>
        <th>èµ·ç‚¹ï¼ˆåœ°å›¾é“¾æ¥ï¼‰</th>
        <th>ç»ˆç‚¹ï¼ˆåœ°å›¾é“¾æ¥ï¼‰</th>
        <th>æœç´¢æ ‡ç­¾</th>
        <th>æ•°æ®</th>
        <th>åª’ä½“</th>
        <th>æ“ä½œ</th>
      </tr>
    </thead>

    <tbody id="mscTableBody"></tbody>
  </table>
</div>

<!-- TAB â‘¡ï¼šå¤©æ°”èŠ‚ç‚¹ï¼ˆåªè¯»ï¼‰ -->
<div id="tabWeather" class="tab-content">
  <h3>å¤©æ°”èŠ‚ç‚¹ï¼ˆåªè¯» â€”â€” æ¥è‡ª G1ï¼‰</h3>

  <table>
    <thead>
      <tr>
        <th>#</th>
        <th>ç±»åˆ«</th>
        <th>æ ‡é¢˜ï¼ˆç®€ç§°ï¼‰</th>
        <th>å‰¯æ ‡é¢˜ï¼ˆæè¿°ï¼‰</th>
        <th>é‡Œç¨‹åŒºé—´</th>
        <th>æµ·æ‹”åŒºé—´</th>
        <th>èµ·ç‚¹ï¼ˆåœ°å›¾é“¾æ¥ï¼‰</th>
        <th>ç»ˆç‚¹ï¼ˆåœ°å›¾é“¾æ¥ï¼‰</th>
        <th>æœç´¢æ ‡ç­¾</th>
        <th>æ•°æ®</th>
        <th>åª’ä½“</th>
        <th>æ“ä½œ</th>
      </tr>
    </thead>

    <tbody id="weatherTableBody"></tbody>
  </table>
</div>

<!-- TAB â‘¢ï¼šåœ°å½¢è‡ªç„¶åˆ†æ®µ -->
<div id="tabSegments" class="tab-content">
  <h3>åœ°å½¢è‡ªç„¶åˆ†æ®µï¼ˆç³»ç»Ÿè‡ªåŠ¨ + å¯äººå·¥ä¿®è®¢ï¼‰</h3>

  <table>
    <thead>
      <tr>
        <th>#</th>
        <th>ç±»åˆ«</th>
        <th>æ ‡é¢˜ï¼ˆç®€ç§°ï¼‰</th>
        <th>å‰¯æ ‡é¢˜ï¼ˆæè¿°ï¼‰</th>
        <th>é‡Œç¨‹åŒºé—´</th>
        <th>æµ·æ‹”åŒºé—´</th>
        <th>èµ·ç‚¹ï¼ˆåœ°å›¾é“¾æ¥ï¼‰</th>
        <th>ç»ˆç‚¹ï¼ˆåœ°å›¾é“¾æ¥ï¼‰</th>
        <th>æœç´¢æ ‡ç­¾</th>
        <th>æ•°æ®</th>
        <th>åª’ä½“</th>
        <th>æ“ä½œ</th>
      </tr>
    </thead>

    <tbody id="segTableBody"></tbody>
  </table>
</div>

<!-- åœ°å›¾é€‰æ‹©å¼¹çª— -->
<div id="mapModal">
  <div id="mapContainer">

    <div id="mapToolbar">
      <select id="basemapSelect" onchange="switchBaseMap(this.value)">
        <option value="topo">OpenTopoMapï¼ˆé»˜è®¤åœ°å½¢ï¼‰</option>
        <option value="hikebike">HikeBikeï¼ˆå¾’æ­¥/éª‘è¡Œï¼‰</option>
        <option value="osm">æ ‡å‡† OSM</option>
      </select>

      <input id="mapSearchBox" type="text" placeholder="æœç´¢ä½ç½®â€¦" style="flex:1;">
      <button onclick="searchLocation()">æœç´¢</button>

      <button class="success" onclick="confirmPoint()">ç¡®å®š</button>
      <button class="danger" onclick="closeMap()">å…³é—­</button>
    </div>

    <div id="map"></div>
  </div>
</div>

<script>
let G1_DATA = null;
//-----------------------------------------------------
// â˜… ä» G1.html å†™å…¥çš„ localStorage è¯»å–è‡ªç„¶åˆ†æ®µ JSON
//-----------------------------------------------------
(function () {
    const raw = localStorage.getItem("G1_NATURAL_JSON");
    if (raw) {
        try {
            G1_DATA = JSON.parse(raw);
            console.log("ğŸ“¥ å·²æˆåŠŸè½½å…¥è‡ªç„¶åˆ†æ®µ JSONï¼š", G1_DATA);
        } catch (err) {
            console.error("âŒ JSON è§£æå¤±è´¥ï¼š", err);
        }
    } else {
        console.warn("âš  æœªæ¥æ”¶åˆ°è‡ªç„¶åˆ†æ®µ JSONï¼Œè¯·æ£€æŸ¥ G1 é¡µé¢æ˜¯å¦æ‰§è¡Œäº†ã€ç”Ÿæˆè‡ªç„¶åˆ†æ®µã€");
    }
})();

/* ========== Tab åˆ‡æ¢ï¼ˆä¿®æ­£ç‰ˆï¼ŒåŠ å…¥ editorï¼‰ ========== */
function switchTab(which) {

  // å…¨éƒ¨éšè—
  document.getElementById('tabScenes').classList.remove('active');
  document.getElementById('tabWeather').classList.remove('active');
  document.getElementById('tabSegments').classList.remove('active');

  // å–æ¶ˆæŒ‰é’®æ¿€æ´»çŠ¶æ€
  document.getElementById('tabBtnScenes').classList.remove('active');
  document.getElementById('tabBtnWeather').classList.remove('active');
  document.getElementById('tabBtnSegments').classList.remove('active');

  // æ‰“å¼€å¯¹åº” tab
  if (which === 'scenes') {
    document.getElementById('tabScenes').classList.add('active');
    document.getElementById('tabBtnScenes').classList.add('active');
  }
  else if (which === 'weather') {
    document.getElementById('tabWeather').classList.add('active');
    document.getElementById('tabBtnWeather').classList.add('active');
  }
  else if (which === 'segments') {
    document.getElementById('tabSegments').classList.add('active');
    document.getElementById('tabBtnSegments').classList.add('active');
  }
}

function receiveFromG1(data) {
  localStorage.setItem("G1_FROM_ANALYZER", JSON.stringify(data));
}

/* ========== åŠ è½½ JSON ========== */
function loadJSON() {
  const file = document.getElementById("jsonInput").files[0];
  if (!file) return alert("è¯·é€‰æ‹© JSON æ–‡ä»¶");

  const reader = new FileReader();
  reader.onload = e => {
    try {
      G1_DATA = JSON.parse(e.target.result);
      initDataAfterLoad();
      document.getElementById("loadStatus").innerHTML =
        "<span style='color:green'>âœ” JSON åŠ è½½æˆåŠŸ</span>";
    } catch (err) {
      console.error(err);
      alert("JSON æ ¼å¼é”™è¯¯ï¼Œè¯·æ£€æŸ¥ï¼");
    }
  };
  reader.readAsText(file);
}

/* ========== åˆå§‹åŒ– & æ¸²æŸ“å…¥å£ ========== */
function initDataAfterLoad() {
  /* ============================================================
   â˜…â˜… STEP 1ï¼šå…¼å®¹ G1 é¡µé¢å¯¼å…¥çš„ JSON å­—æ®µï¼ˆæœ€å…³é”®çš„ç»Ÿåˆå±‚ï¼‰
   ============================================================ */

// â­ åœ°å½¢æ®µï¼šnaturalSegments â†’ segments
if (!Array.isArray(G1_DATA.segments) && Array.isArray(G1_DATA.naturalSegments)) {
    console.log("âš¡ å…¼å®¹å­—æ®µï¼šnaturalSegments â†’ segments");
    G1_DATA.segments = G1_DATA.naturalSegments;
}

// â­ å¤©æ°”èŠ‚ç‚¹ï¼šweather â†’ weatherNodes
if (!Array.isArray(G1_DATA.weatherNodes) && Array.isArray(G1_DATA.weather)) {
    console.log("âš¡ å…¼å®¹å­—æ®µï¼šweather â†’ weatherNodes");
    G1_DATA.weatherNodes = G1_DATA.weather;
}

// â­ è½¨è¿¹ï¼štrack â†’ profileï¼ˆG1 å†…å« trackï¼Œä½†ç¼–è¾‘å™¨ç”¨ profileï¼‰
if (!Array.isArray(G1_DATA.profile) && Array.isArray(G1_DATA.track)) {
    console.log("âš¡ å…¼å®¹å­—æ®µï¼štrack â†’ profile");
    G1_DATA.profile = G1_DATA.track;
}

// â­ äººå·¥èŠ‚ç‚¹ä¸ºç©ºä½†å­˜åœ¨ manualScenesï¼Œä¹Ÿè¦ç¡®ä¿ç»“æ„æ­£ç¡®
if (!Array.isArray(G1_DATA.manualScenes)) {
    G1_DATA.manualScenes = [];
}

  // ğŸ”¥ åŠ åœ¨è¿™é‡Œï¼ç”¨äºæ£€æŸ¥å¤©æ°”å­—æ®µåˆ°åº•å«ä»€ä¹ˆ
  console.log("ğŸ‘‰ å¤©æ°”å­—æ®µæ£€æŸ¥ï¼š", {
    weatherNodes: G1_DATA?.weatherNodes,
    weather: G1_DATA?.weather,
    weatherList: G1_DATA?.weatherList
  });
  console.log("ğŸ‘‰ åœ°å½¢å­—æ®µæ£€æŸ¥ï¼š", {
  segments: G1_DATA?.segments,
  terrainList: G1_DATA?.terrainList,
  terrain: G1_DATA?.terrain
});


  if (!G1_DATA) return;

  if (!Array.isArray(G1_DATA.segments)) G1_DATA.segments = [];
  if (!Array.isArray(G1_DATA.weatherNodes)) G1_DATA.weatherNodes = [];
  if (!Array.isArray(G1_DATA.manualScenes)) G1_DATA.manualScenes = [];

  // åœ°å½¢æ®µé»˜è®¤æ ‡é¢˜ / å‰¯æ ‡é¢˜
  G1_DATA.segments.forEach(seg => {
    if (!seg.title) seg.title = seg.type || "";
    if (!seg.subtitle) seg.subtitle = seg.desc || "";
  });

  renderWeather();
  renderSegments();
 renderManualScenes();
// â­ å¦‚æœåœ°å›¾å·²ç»å­˜åœ¨ï¼Œåˆ™æ ¹æ®æ–°çš„ profile é‡ç”»è½¨è¿¹
if (map) {
  drawRouteProfile();
}
}   // â† â˜…â˜…â˜… è¿™é‡Œå¿…é¡»æœ‰ä¸€ä¸ªå¤§æ‹¬å·å…³é—­ initDataAfterLoad()


/* æ’å…¥è¿™é‡Œ */
function syncSegmentsFromUI() {
  if (!G1_DATA || !Array.isArray(G1_DATA.segments)) return;

  G1_DATA.segments = G1_DATA.segments.map((seg, i) => ({
    ...seg,
    title:    document.getElementById(`title_${i}`)?.value || "",
    subtitle: document.getElementById(`subtitle_${i}`)?.value || "",
    tags:     document.getElementById(`seg_tags_${i}`)?.value || "",
    data:     document.getElementById(`seg_data_${i}`)?.value || "",
    media:    document.getElementById(`seg_media_${i}`)?.value || ""
  }));
}

/* æ’å…¥ç»“æŸ */


/* ========== å°å·¥å…·ï¼šåœ¨ profile ä¸­æ ¹æ® km ä¼°ç®—æµ·æ‹” ========== */
function getEleAtKm(km) {
  if (!G1_DATA || !Array.isArray(G1_DATA.profile) || G1_DATA.profile.length === 0) {
    return null;
  }
  const prof = G1_DATA.profile;
  if (km <= prof[0].km) return prof[0].ele;
  const last = prof[prof.length - 1];
  if (km >= last.km) return last.ele;

  for (let i = 1; i < prof.length; i++) {
    const p0 = prof[i - 1];
    const p1 = prof[i];
    if (km <= p1.km) {
      const span = p1.km - p0.km || 1;
      const t = (km - p0.km) / span;
      return Math.round(p0.ele + t * (p1.ele - p0.ele));
    }
  }
  return null;
}
/* ========== æ¸²æŸ“å¤©æ°”è¡¨ï¼ˆç»“æ„å®Œå…¨å¯¹é½ G1 æŠ¥å‘Šï¼‰ ========== */
function renderWeather() {
  const body = document.getElementById("weatherTableBody");
  body.innerHTML = "";
  if (!G1_DATA || !Array.isArray(G1_DATA.weatherNodes)) return;

  G1_DATA.weatherNodes.forEach((w, i) => {
    const id = w.id || ("W" + (i + 1));

    /* km åŒºé—´æ ¼å¼ */
    let kmRange = "â€”";
    if (typeof w.km === "number") {
      const k = w.km.toFixed(2);
      kmRange = `${k}â€“${k} km`;
    } else if (typeof w.km === "string" && w.km.trim()) {
      kmRange = w.km;
    }

    /* æµ·æ‹”åŒºé—´ï¼šå¦‚ w.ele æœªæä¾›ï¼Œåˆ™ä» G1 profile ä¸­æ’å€¼ */
    let eleRange = "â€”";
    let ele = null;
    if (typeof w.ele === "number") {
      ele = w.ele;
      eleRange = `${ele}â€“${ele} m`;
    } else if (typeof w.km === "number") {
      ele = getEleAtKm(w.km);
      if (typeof ele === "number") eleRange = `${ele}â€“${ele} m`;
    }

    /* ======== æ ‡é¢˜ï¼ˆå¤©æ°” + æ¸©åº¦åŒºé—´ï¼‰ ======== */
    const weatherType =
      w.weather || w.wxShort || w.main || w.type || "";

    let tempShort = "";
    if (typeof w.tMin === "number" && typeof w.tMax === "number") {
      tempShort = `${w.tMin}â€“${w.tMax}â„ƒ`;
    } else if (w.temp) {
      tempShort = w.temp;  // å…¼å®¹æ—§å­—æ®µ
    }

    /* ======== å‰¯æ ‡é¢˜ï¼šç®€çŸ­ summaryï¼ˆä½“æ„Ÿæœ€åï¼‰ ======== */
    let desc = w.summary || "";  // è‹¥ G1 å·²ç»™ summaryï¼Œåˆ™ç›´æ¥ç”¨

    if (!desc) {
      const parts = [];

      const midT =
        (typeof w.tMin === "number" && typeof w.tMax === "number")
          ? Math.round((w.tMin + w.tMax) / 2)
          : (typeof w.midT === "number" ? w.midT : null);

      if (weatherType) parts.push(weatherType);
      if (midT !== null) parts.push(`${midT}Â°`);
      if (typeof w.wind === "number") parts.push(`${w.wind}m/s`);
      if (typeof w.pop === "number") parts.push(`${w.pop}%`);
      if (typeof w.uv === "number") parts.push(`UV ${w.uv}`);
      if (typeof w.feel === "number") parts.push(`ä½“æ„Ÿ ${w.feel}Â°`);

      desc = parts.join(" | ");
    }

    const lat = w.lat ?? "";
    const lon = w.lon ?? "";

    /* ======== è¡Œæ¸²æŸ“ ======== */
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>${i + 1}</td>

      <!-- ç±»åˆ« -->
      <td>å¤©æ°”</td>

      <!-- æ ‡é¢˜ï¼ˆå¤©æ°” + æ¸©åº¦åŒºé—´ï¼‰ -->
      <td>${weatherType} ${tempShort}</td>

      <!-- å‰¯æ ‡é¢˜ï¼ˆç®€çŸ­æè¿°ï¼šä½“æ„Ÿæ°¸è¿œæ”¾æœ€åï¼‰ -->
      <td>${desc}</td>

      <!-- é‡Œç¨‹åŒºé—´ -->
      <td>${kmRange}</td>

      <!-- æµ·æ‹”åŒºé—´ -->
      <td>${eleRange}</td>

      <!-- èµ·ç‚¹ -->
      <td>
        ${
          lat && lon
            ? `<a href="https://www.openstreetmap.org/?mlat=${lat}&mlon=${lon}&zoom=14"
                 target="_blank">${lat}, ${lon}</a><br>`
            : ""
        }
        <button onclick="openWeatherMap(${i}, 'start')">é€‰èµ·ç‚¹</button>
      </td>

      <!-- ç»ˆç‚¹ -->
      <td>
        ${
          lat && lon
            ? `<a href="https://www.openstreetmap.org/?mlat=${lat}&mlon=${lon}&zoom=14"
                 target="_blank">${lat}, ${lon}</a><br>`
            : ""
        }
        <button onclick="openWeatherMap(${i}, 'end')">é€‰ç»ˆç‚¹</button>
      </td>

      <td></td>
      <td></td>
      <td></td>

      <td></td>
    `;

    body.appendChild(tr);
  });
}

/* ========== é€‰æ‹©å¤©æ°”ç‚¹åœ°å›¾å®šä½ ========== */
function openWeatherMap(i, pickType) {
  MapPicker.open("weather", i, pickType, (action, data) => {
    const w = G1_DATA.weatherNodes[i];

    if (action === "getCurrentPoint") {
      return { lat: w.lat, lon: w.lon };
    }

    if (action === "setPoint") {
      w.lat = data.lat;
      w.lon = data.lon;

      renderWeather();
    }
  });
}

/* ========== æ¸²æŸ“åœ°å½¢è‡ªç„¶åˆ†æ®µ ========== */
/* ========== æ¸²æŸ“åœ°å½¢è‡ªç„¶åˆ†æ®µï¼ˆå¯æ–°å¢ / åˆ é™¤ / ç¼–è¾‘ï¼‰ ========== */
function renderSegments() {
  const body = document.getElementById("segTableBody");
  body.innerHTML = "";

  if (!G1_DATA || !Array.isArray(G1_DATA.segments)) return;

  G1_DATA.segments.forEach((seg, i) => {
    const s = seg.startPt || {};
    const e = seg.endPt || {};

    const startKm = seg.startKm?.toFixed ? seg.startKm.toFixed(2) : seg.startKm ?? "";
    const endKm = seg.endKm?.toFixed ? seg.endKm.toFixed(2) : seg.endKm ?? "";
    const kmRange = `${startKm} â€“ ${endKm} km`;

    const eleRange =
      seg.startEle != null && seg.endEle != null
        ? `${seg.startEle} â€“ ${seg.endEle} m`
        : "â€”";

    const tr = document.createElement("tr");

    tr.innerHTML = `
      <td>${seg.id ?? i + 1}</td>

      <td>åœ°å½¢</td>

      <td><input id="title_${i}" value="${seg.title ?? ""}"></td>

      <td><textarea id="subtitle_${i}" rows="2">${seg.subtitle ?? ""}</textarea></td>

      <td id="km_range_${i}">${kmRange}</td>

      <td id="ele_range_${i}">${eleRange}</td>

      <td>
        ${
          s.lat && s.lon
            ? `<a href="https://www.openstreetmap.org/?mlat=${s.lat}&mlon=${s.lon}&zoom=14" target="_blank">${s.lat}, ${s.lon}</a><br>`
            : ""
        }
        <button onclick="openSegmentMap(${i}, 'start')">é€‰èµ·ç‚¹</button>
      </td>

      <td>
        ${
          e.lat && e.lon
            ? `<a href="https://www.openstreetmap.org/?mlat=${e.lat}&mlon=${e.lon}&zoom=14" target="_blank">${e.lat}, ${e.lon}</a><br>`
            : ""
        }
        <button onclick="openSegmentMap(${i}, 'end')">é€‰ç»ˆç‚¹</button>
      </td>

      <td><input id="seg_tags_${i}" value="${seg.tags || ""}"></td>

      <td><textarea id="seg_data_${i}" rows="2">${seg.data || ""}</textarea></td>

      <td><input id="seg_media_${i}" value="${seg.media || ""}"></td>

      <td>
        <button class="success" onclick="addSegmentAfter(${i})">ï¼‹</button>
        <button class="danger" onclick="deleteSegment(${i})">åˆ </button>
      </td>
    `;

    body.appendChild(tr);
  });
}

/* ========== æ–°å¢åœ°å½¢æ®µï¼ˆæ’å…¥å½“å‰ä½ç½®ä¹‹åï¼‰ ========== */
function addSegmentAfter(i) {
  const segs = G1_DATA.segments;

  const curr = segs[i];
  const next = segs[i + 1];

  const midKm =
    next && next.startKm != null
      ? (curr.endKm + next.startKm) / 2
      : curr.endKm + 0.1;

  // æ–°æ®µæ¨¡æ¿
  const newSeg = {
    id: "T" + (segs.length + 1),
    type: curr.type,
    title: curr.title,
    subtitle: "",
    startKm: midKm,
    endKm: midKm + 0.05,
    startPt: { lat: null, lon: null },
    endPt: { lat: null, lon: null },
    tags: "",
    data: "",
    media: ""
  };

  segs.splice(i + 1, 0, newSeg);

  renderSegments();
}


/* ========== åˆ é™¤åœ°å½¢æ®µ ========== */
function deleteSegment(i) {
  const segs = G1_DATA.segments;

  if (segs.length <= 1) {
    alert("è‡³å°‘è¦ä¿ç•™ 1 ä¸ªåœ°å½¢æ®µ");
    return;
  }

  const prev = segs[i - 1];
  const next = segs[i + 1];

  // è‡ªåŠ¨ä¿®å¤æ‹“æ‰‘ï¼šæŠŠåˆ é™¤æ®µçš„åŒºé—´è®©ç»™ä¸‹ä¸€æ®µ
  if (prev && next) {
    next.startKm = prev.endKm;
  }

  segs.splice(i, 1);
  renderSegments();
}

/* =====================================================
   åœ°å½¢åˆ†æ®µåœ°å›¾æ‹¾å–ï¼ˆå¤ç”¨ MapPickerï¼‰
===================================================== */
function openSegmentMap(i, pickType) {
  MapPicker.open("segment", i, pickType, (action, data) => {
    const seg = G1_DATA.segments[i];

    if (action === "getCurrentPoint") {
      return pickType === "start" ? seg.startPt : seg.endPt;
    }

    if (action === "setPoint") {
      if (pickType === "start") {
        seg.startPt = { lat: data.lat, lon: data.lon };
      } else {
        seg.endPt = { lat: data.lat, lon: data.lon };
      }

      // è‡ªåŠ¨åæ¨ km / ele
      const profStart = snapToProfile(seg.startPt.lat, seg.startPt.lon, G1_DATA.profile);
      const profEnd   = snapToProfile(seg.endPt.lat, seg.endPt.lon, G1_DATA.profile);

      seg.startKm = profStart.km;
      seg.endKm   = profEnd.km;
      seg.startEle = profStart.ele;
      seg.endEle   = profEnd.ele;

      // â˜…â˜…â˜… ç­–ç•¥ Cï¼šæ‹“æ‰‘æ ¡éªŒ
      if (!SegmentManager.validateTopology(i)) return;

      renderSegments();
    }
  });
}

/* =====================================================
   â­ åœ°å½¢æ®µæ‹“æ‰‘æ ¡éªŒï¼ˆé˜²æ­¢æ®µé‡å /åè½¬/äºŒåˆä¸€ï¼‰
   ===================================================== */
function fixSegmentTopology(i) {
  const segs = G1_DATA.segments;
  const seg = segs[i];

  const prev = segs[i - 1];
  const next = segs[i + 1];

  // 1ï¸âƒ£ å½“å‰æ®µä¸èƒ½åè½¬ï¼ˆå¿…é¡» start < endï¼‰
  if (seg.startKm >= seg.endKm) {
    alert("å½“å‰åœ°å½¢æ®µçš„èµ·ç‚¹å¿…é¡»å°äºç»ˆç‚¹ï¼Œè¯·é‡æ–°é€‰æ‹©åœ°ç‚¹ï¼");
    return false;
  }

  // 2ï¸âƒ£ ä¿®å¤ä¸Šä¸€æ®µï¼šä¸å…è®¸ä¸Šä¸€æ®µç»ˆç‚¹ > æœ¬æ®µèµ·ç‚¹
  if (prev) {
    if (prev.endKm > seg.startKm) {
      const diff = prev.endKm - seg.startKm;

      // å…è®¸å¾®è°ƒ 200 ç±³
      if (diff <= 0.2) {
        prev.endKm = seg.startKm;
      } else {
        alert("è°ƒæ•´è¿‡å¤§ï¼Œä¼šå¯¼è‡´ä¸Šä¸€æ®µä¸æœ¬æ®µé‡å ï¼Œè¯·é‡æ–°é€‰æ‹©åœ°ç‚¹ï¼");
        return false;
      }
    }
  }

  // 3ï¸âƒ£ ä¿®å¤ä¸‹ä¸€æ®µï¼šä¸å…è®¸ä¸‹ä¸€æ®µèµ·ç‚¹ < æœ¬æ®µç»ˆç‚¹
  if (next) {
    if (next.startKm < seg.endKm) {
      const diff = seg.endKm - next.startKm;

      // å…è®¸å¾®è°ƒ 200 ç±³
      if (diff <= 0.2) {
        next.startKm = seg.endKm;
      } else {
        alert("è°ƒæ•´è¿‡å¤§ï¼Œä¼šå¯¼è‡´æœ¬æ®µä¸ä¸‹ä¸€æ®µé‡å ï¼Œè¯·é‡æ–°é€‰æ‹©åœ°ç‚¹ï¼");
        return false;
      }
    }
  }

  return true;
}


/* ========== æ¸²æŸ“äººå·¥åœºæ™¯èŠ‚ç‚¹ ========== */
function renderManualScenes() {

  normalizeManualScenes();   
  const body = document.getElementById("mscTableBody");
  body.innerHTML = "";

  if (!G1_DATA || !Array.isArray(G1_DATA.manualScenes)) return;

  G1_DATA.manualScenes.forEach((msc, i) => {

    const tr = document.createElement("tr");

    tr.innerHTML = `
      <td>${i + 1}</td>

      <td>äººå·¥èŠ‚ç‚¹</td>

      <td>
       <input id="msc_name_${i}" value="${msc.name || msc.shortName || ""}">
      </td>

      <td>
        <textarea id="msc_desc_${i}" rows="2">${msc.desc || ""}</textarea>
      </td>

      <td>${msc.kmRange || ""}</td>
      <td>${msc.eleRange || ""}</td>

      <td>
        <a href="https://www.openstreetmap.org/?mlat=${msc.startLat}&mlon=${msc.startLon}&zoom=14" target="_blank">
          ${msc.startLat || ""}, ${msc.startLon || ""}
        </a><br>
       <button onclick="pickManual(${i}, 'start')">é€‰èµ·ç‚¹</button>

      </td>

      <td>
        <a href="https://www.openstreetmap.org/?mlat=${msc.endLat}&mlon=${msc.endLon}&zoom=14" target="_blank">
          ${msc.endLat || ""}, ${msc.endLon || ""}
        </a><br>
    <button onclick="pickManual(${i}, 'end')">é€‰ç»ˆç‚¹</button>

      </td>

      <td>
        <input id="msc_tags_${i}" value="${msc.tags || ""}">
      </td>

      <td>
        <textarea id="msc_data_${i}" rows="2">${msc.data || ""}</textarea>
      </td>

      <td>
        <input id="msc_media_${i}" value="${msc.media || ""}">
      </td>

      <td>
        <button class="danger" onclick="deleteManualScene(${i})">åˆ é™¤</button>
      </td>
    `;

    body.appendChild(tr);
  });
}




/* ========== å†™å›äººå·¥èŠ‚ç‚¹ ========== */
function syncManualScenesFromUI() {
  if (!G1_DATA || !Array.isArray(G1_DATA.manualScenes)) return;

  G1_DATA.manualScenes = G1_DATA.manualScenes.map((msc, i) => ({
    ...msc,   // ä¿ç•™ normalizeManualScenes çš„ km/ele/åæ ‡

    id: i + 1,

    name:      document.getElementById(`msc_name_${i}`).value,
    shortName: document.getElementById(`msc_name_${i}`).value,
    title:     document.getElementById(`msc_name_${i}`).value,

    desc:      document.getElementById(`msc_desc_${i}`)?.value || "",
    tags:      document.getElementById(`msc_tags_${i}`)?.value || "",
    data:      document.getElementById(`msc_data_${i}`)?.value || "",
    media:     document.getElementById(`msc_media_${i}`)?.value || ""
  }));
}


/* ============================================================
   Step 3-B: è‡ªåŠ¨è¡¥ç®— manualScenes çš„ km / ele åŒºé—´
   - ä¾èµ–ï¼šG1_DATA.profile + snapToProfile()
   - ä¸å½±å“ï¼šåŸæœ‰å­—æ®µã€åŸæœ‰å¯¼å‡ºé€»è¾‘
============================================================ */
function normalizeManualScenes() {
  if (!G1_DATA || !Array.isArray(G1_DATA.manualScenes) || !Array.isArray(G1_DATA.profile)) {
    return;
  }

  G1_DATA.manualScenes.forEach(msc => {
    const sLat = parseFloat(msc.startLat);
    const sLon = parseFloat(msc.startLon);
    const eLat = parseFloat(msc.endLat);
    const eLon = parseFloat(msc.endLon);

    // åæ ‡ä¸å®Œæ•´å°±æ¸…ç©ºåŒºé—´ï¼Œé¿å…è„æ•°æ®
    if (isNaN(sLat) || isNaN(sLon) || isNaN(eLat) || isNaN(eLon)) {
      msc.startKm = null;
      msc.endKm = null;
      msc.startEle = null;
      msc.endEle = null;
      msc.kmRange = "";
      msc.eleRange = "";
      return;
    }

    // åˆ©ç”¨ profile åŒ¹é…æœ€è¿‘ç‚¹ï¼ˆå‰é¢ Step 3-A å·²ç»æ’å…¥ snapToProfileï¼‰
    const start = snapToProfile(sLat, sLon, G1_DATA.profile);
    const end   = snapToProfile(eLat, eLon, G1_DATA.profile);

    msc.startKm  = start.km;
    msc.endKm    = end.km;
    msc.startEle = start.ele;
    msc.endEle   = end.ele;

    // ç”Ÿæˆæ˜¾ç¤ºç”¨åŒºé—´å­—ç¬¦ä¸²ï¼ˆå¯ç”¨äºè¡¨æ ¼æˆ–æŠ¥å‘Šï¼‰
    if (start.km != null && end.km != null) {
      msc.kmRange = `${start.km.toFixed(3)} - ${end.km.toFixed(3)}`;
    } else {
      msc.kmRange = "";
    }

    if (start.ele != null && end.ele != null) {
      msc.eleRange = `${start.ele} - ${end.ele}`;
    } else {
      msc.eleRange = "";
    }
  });
}


/* ========== æ ¡éªŒäººå·¥èŠ‚ç‚¹æ˜¯å¦å¡«å†™å®Œæ•´ï¼ˆå¿…é¡»æœ‰åæ ‡ï¼‰ ========== */
function validateManualScenes() {
  if (!G1_DATA || !Array.isArray(G1_DATA.manualScenes)) return true;

  for (let i = 0; i < G1_DATA.manualScenes.length; i++) {
    const m = G1_DATA.manualScenes[i];
    const idx = i + 1;

    const sLat = parseFloat(m.startLat);
    const sLon = parseFloat(m.startLon);
    const eLat = parseFloat(m.endLat);
    const eLon = parseFloat(m.endLon);

    if (isNaN(sLat) || isNaN(sLon) || isNaN(eLat) || isNaN(eLon)) {
      alert(`äººå·¥èŠ‚ç‚¹ #${idx}ã€Œ${m.name || "æœªå‘½åèŠ‚ç‚¹"}ã€ç¼ºå°‘åæ ‡ï¼Œè¯·è¡¥å…¨åå†å¯¼å‡ºï¼`);
      return false;
    }
  }
  return true;
}
/* ========== æ–°å¢ & åˆ é™¤ äººå·¥èŠ‚ç‚¹ ========== */
function addManualScene() {
  if (!G1_DATA) {
    alert("è¯·å…ˆåŠ è½½ JSON");
    return;
  }
  if (!Array.isArray(G1_DATA.manualScenes)) {
    G1_DATA.manualScenes = [];
  }

  // âŒ ä¸è¦ syncManualScenesFromUI() â€”â€” ä¼šæ¸…ç©ºè¾“å…¥

  G1_DATA.manualScenes.push({
    id: G1_DATA.manualScenes.length + 1,
    nodeType: "manual",
    name: "",
    desc: "",
    startLat: "",
    startLon: "",
    endLat: "",
    endLon: "",
    lengthM: 30,
    kmRange: "",
    eleRange: "",
    startKm: null,
    endKm: null,
    startEle: null,
    endEle: null,
    tags: "",
    data: "",
    media: ""
  });

  renderManualScenes();
}


function deleteManualScene(i) {
  if (!G1_DATA || !Array.isArray(G1_DATA.manualScenes)) return;

  // âŒ ä¸è¦ syncManualScenesFromUI()
  // åˆ é™¤èŠ‚ç‚¹ä¹‹åè‡ªç„¶ä¼šé‡æ¸²æŸ“ï¼Œæ— éœ€å†™å› UI

  G1_DATA.manualScenes.splice(i, 1);
  renderManualScenes();
}

/* =====================================================
   ğŸŒ é€šç”¨åœ°å›¾æ‹¾å–å°è£…æ¨¡å— MapPicker
===================================================== */

const MapPicker = {
  mode: null,          // manual | segment | future node types
  index: null,         // row index
  pickType: null,      // "start" | "end"
  callback: null,      // å†™å›å›è°ƒ

  open(mode, index, pickType, callback) {
    // â­ 1ï¼‰å¿…é¡»å…ˆæœ‰ G1_DATA å’Œ profileï¼Œæ‰èƒ½ç”»è½¨è¿¹ / å®šä½
    if (!G1_DATA || !Array.isArray(G1_DATA.profile) || G1_DATA.profile.length === 0) {
      alert("è¯·å…ˆåŠ è½½å¸¦æœ‰è½¨è¿¹ profile çš„ JSONï¼ˆæˆ–ä» G1 é¡µé¢è·³è½¬è¿›æ¥ï¼‰");
      return;
    }
    this.mode = mode;
    this.index = index;
    this.pickType = pickType;
    this.callback = callback;

    selectedLat = null;
    selectedLon = null;

    document.getElementById("mapModal").style.display = "block";

    // æ‰“å¼€åœ°å›¾
    if (!map) {
      map = L.map("map", { zoomControl: true }).setView([0, 0], 3);
      baseLayers.osm.addTo(map);
 // â˜…â˜…â˜…â˜…â˜… åœ¨è¿™æ’å…¥ï¼šç¬¬ä¸€æ¬¡åˆå§‹åŒ–åœ°å›¾åç»˜åˆ¶è½¨è¿¹
      drawRouteProfile();
      // ç‚¹å‡»æ‹¾å–ç‚¹
      map.on("click", e => {
        selectedLat = e.latlng.lat.toFixed(6);
        selectedLon = e.latlng.lng.toFixed(6);

        if (mapMarker) mapMarker.remove();
        mapMarker = L.marker(e.latlng).addTo(map);
      });
    }

    // å®šä½å½“å‰èŠ‚ç‚¹ä½ç½®ï¼ˆè°ƒç”¨æ–¹è¿”å›ï¼‰
    const pt = callback("getCurrentPoint");
    if (pt?.lat && pt?.lon) {
      map.setView([pt.lat, pt.lon], 15);
      if (mapMarker) mapMarker.remove();
      mapMarker = L.marker([pt.lat, pt.lon]).addTo(map);
    } else {
      // å¦‚æœæ²¡æœ‰ç»çº¬åº¦ â†’ å®šä½åˆ°èµ·å§‹è½¨è¿¹
      const s0 = G1_DATA.profile?.[0];
      if (s0?.lat && s0?.lon) {
        map.setView([s0.lat, s0.lon], 13);
      }
    }

    // ç¡®ä¿åœ°å›¾ä¸å‹ç¼©
    setTimeout(() => map.invalidateSize(true), 200);
  },

  confirm() {
    if (!selectedLat || !selectedLon) {
      if (!mapMarker) return alert("è¯·å…ˆé€‰æ‹©ä½ç½®");
      const ll = mapMarker.getLatLng();
      selectedLat = ll.lat.toFixed(6);
      selectedLon = ll.lng.toFixed(6);
    }

    this.callback("setPoint", {
      lat: +selectedLat,
      lon: +selectedLon
    });

    closeMap();
  }
};


let mapMarker = null;
let currentPickIndex = null;
let currentPickType = null;
let selectedLat = null;
let selectedLon = null;
let map = null;
let routeLine = null; // â­ ç”¨æ¥ä¿å­˜è½¨è¿¹æŠ˜çº¿

/* æ­£å¸¸çš„åº•å›¾ï¼ˆä¿®å¤ä¸å¯ç”¨çš„ HikeBike æºï¼‰ */
const baseLayers = {
  topo: L.tileLayer("https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png", {
    maxZoom: 17,
    attribution: "Â© OpenTopoMap"
  }),
  osm: L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
    maxZoom: 19,
    attribution: "Â© OpenStreetMap"
  }),
  hikebike: L.tileLayer("https://tile.waymarkedtrails.org/hiking/{z}/{x}/{y}.png", {
    maxZoom: 18,
    attribution: "Â© Waymarked Trails"
  })
};
/* â­ ç»˜åˆ¶å½“å‰è·¯çº¿è½¨è¿¹ï¼ˆæ ¹æ® G1_DATA.profileï¼‰ */
function drawRouteProfile() {
  if (!map) return;                 // åœ°å›¾è¿˜æ²¡åˆå§‹åŒ–å°±ä¸ç”»
  if (!G1_DATA || !Array.isArray(G1_DATA.profile)) return;

  // å–å‡ºæ‰€æœ‰æœ‰ç»çº¬åº¦çš„ç‚¹
  const pts = G1_DATA.profile
    .filter(p => p.lat != null && p.lon != null)
    .map(p => [p.lat, p.lon]);

  if (!pts.length) return;

  // å¦‚æœä¹‹å‰å·²ç»ç”»è¿‡ä¸€æ¬¡ï¼Œå…ˆç§»é™¤
  if (routeLine) {
    try { routeLine.remove(); } catch (e) {}
    routeLine = null;
  }

  // ç”»ä¸€æ¡çº¢è‰²è½¨è¿¹çº¿
  routeLine = L.polyline(pts, {
    weight: 3,
    opacity: 0.9
  }).addTo(map);

  // è®©åœ°å›¾è§†é‡åˆšå¥½åŒ…ä½æ•´æ¡è½¨è¿¹
  map.fitBounds(routeLine.getBounds());
}

/* è½¨è¿¹ä¸­ç‚¹ï¼ˆprofile æ²¡æœ‰ lat/lon æ—¶ä¸ä¼šå‡ºé”™ï¼‰*/
function getProfileCenter() {
  const p = G1_DATA?.profile;
  if (Array.isArray(p) && p.length > 3) {
    const mid = p[Math.floor(p.length / 2)];
    if (mid.lat && mid.lon) return [mid.lat, mid.lon];
  }
  return [30, 103]; // fallback
}



/* åˆ‡æ¢åº•å›¾ */
function switchBaseMap(type) {
  if (!map) return;
  Object.values(baseLayers).forEach(l => {
    try { map.removeLayer(l); } catch (e) {}
  });
  baseLayers[type]?.addTo(map);
}

/* æœç´¢ */
function searchLocation() {
  const q = document.getElementById("mapSearchBox").value.trim();
  if (!q) return;

  fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(q)}`)
    .then(r => r.json())
    .then(res => {
      if (!res.length) return alert("æœªæ‰¾åˆ°ä½ç½®");

      const lat = parseFloat(res[0].lat);
      const lon = parseFloat(res[0].lon);

      map.setView([lat, lon], 15);

      if (mapMarker) mapMarker.remove();
      mapMarker = L.marker([lat, lon]).addTo(map);

      selectedLat = lat.toFixed(6);
      selectedLon = lon.toFixed(6);
    });
}

/* ç¡®å®š */
function confirmPoint() {
  MapPicker.confirm();
}


/* å…³é—­åœ°å›¾ */
function closeMap() {
  document.getElementById("mapModal").style.display = "none";
}

/* ========== å…³é—­åœ°å›¾å¼¹çª— ========== */
function closeMap() {
  document.getElementById("mapModal").style.display = "none";
}

/* ========== æ ¹æ®ä¸¤ç‚¹ç»çº¬åº¦è®¡ç®—è·ç¦»ï¼ˆç±³ï¼‰ ========== */
function computeLength(i) {
  function rad(x) { return x * Math.PI / 180; }

  const lat1 = +document.getElementById(`msc_lat_${i}`).value;
  const lon1 = +document.getElementById(`msc_lon_${i}`).value;
  const lat2 = +document.getElementById(`msc_lat_end_${i}`).value;
  const lon2 = +document.getElementById(`msc_lon_end_${i}`).value;

  const R = 6378137;
  const dLat = rad(lat2 - lat1);
  const dLon = rad(lon2 - lon1);
  const a =
    Math.sin(dLat / 2) ** 2 +
    Math.cos(rad(lat1)) * Math.cos(rad(lat2)) * Math.sin(dLon / 2) ** 2;

  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  const dist = Math.round(R * c);

  document.getElementById(`msc_length_${i}`).value = dist;
}

function pickManual(i, pickType) {
  MapPicker.open("manual", i, pickType, (action, data) => {
    const m = G1_DATA.manualScenes[i];

    if (action === "getCurrentPoint") {
      return pickType === "start"
        ? { lat: parseFloat(m.startLat), lon: parseFloat(m.startLon) }
        : { lat: parseFloat(m.endLat), lon: parseFloat(m.endLon) };
    }

        if (action === "setPoint") {
      // â‘  æŠŠå½“å‰æ‰€æœ‰è¾“å…¥å†™å› G1_DATAï¼Œé˜²æ­¢é‡æ¸²æŸ“ä¸¢å†…å®¹
      syncManualScenesFromUI();

      const m = G1_DATA.manualScenes[i];

      // â‘¡ æ›´æ–°åæ ‡
      if (pickType === "start") {
        m.startLat = data.lat;
        m.startLon = data.lon;
      } else {
        m.endLat = data.lat;
        m.endLon = data.lon;
      }

      // â‘¢ è‡ªåŠ¨é‡æ–°è®¡ç®— km & ele
      normalizeManualScenes();

      // â‘£ åˆ·æ–° UI
      renderManualScenes();
    }

  });
}


/* =====================================================
   A5 â€”â€” å¯¼å‡º / è‰ç¨¿ä¿å­˜ / è‡ªåŠ¨åŠ è½½ï¼ˆå¢å¼ºç‰ˆï¼‰
===================================================== */

// ========= è§„èŒƒåŒ–äººå·¥èŠ‚ç‚¹ï¼ˆæ—§ç‰ˆï¼Œå·²åºŸå¼ƒï¼Œä¿ç•™å¤‡æŸ¥ï¼‰ =========
function normalizeManualScenesLegacy() {
  if (!G1_DATA || !Array.isArray(G1_DATA.manualScenes)) return [];

  return G1_DATA.manualScenes.map(msc => {
    const sLat = parseFloat(msc.startLat);
    const sLon = parseFloat(msc.startLon);
    const eLat = parseFloat(msc.endLat);
    const eLon = parseFloat(msc.endLon);

    return {
      id: msc.id,
      type: "äººå·¥èŠ‚ç‚¹",

      // ä¸ segments å¯¹é½çš„å­—æ®µ
      title: msc.name || "",
      subtitle: msc.desc || "",

      startPt: {
        lat: isNaN(sLat) ? null : sLat,
        lon: isNaN(sLon) ? null : sLon,
        ele: null
      },
      endPt: {
        lat: isNaN(eLat) ? null : eLat,
        lon: isNaN(eLon) ? null : eLon,
        ele: null
      },

      // è¿›åº¦æ¡é•¿åº¦
      lengthM: Number(msc.lengthM || 30)
    };
  });
}

/* ============================================================
   â­ æ–°å¢ï¼šæŠŠ segments + weatherNodes + manualScenes â†’ nodes[]
   ============================================================ */
function buildNodesV16() {
  const nodes = [];

  /* ---- åœ°å½¢ï¼ˆsegmentsï¼‰ â†’ nodes ---- */
  if (Array.isArray(G1_DATA.segments)) {
    G1_DATA.segments.forEach((seg, i) => {
      nodes.push({
        id: seg.id || ("T" + (i + 1)),
        nodeType: "terrain",

        startKm: seg.startKm ?? null,
        endKm: seg.endKm ?? null,
        positionKm: seg.startKm ?? null,   // â˜… æ–°å¢ï¼šæŠ½å±‰åˆ—è¡¨æ˜¾ç¤ºç”¨

        startPt: seg.startPt || {
          lat: seg.startLat ?? null,
          lon: seg.startLon ?? null,
          ele: seg.startEle ?? null
        },
        endPt: seg.endPt || {
          lat: seg.endLat ?? null,
          lon: seg.endLon ?? null,
          ele: seg.endEle ?? null
        },

        shortName: seg.type || "",
        title: seg.title || "",
        desc: seg.subtitle || seg.desc || "",

        tags: [],
        algo: "terrain-v1",

        data: {
          deltaEle: seg.deltaEle,
          slopePct: seg.slopePct
        }
      });
    });
  }

  /* ---- å¤©æ°”ï¼ˆweatherNodesï¼‰ â†’ nodes ---- */
if (Array.isArray(G1_DATA.weatherNodes)) {
  G1_DATA.weatherNodes.forEach((w, i) => {

    /* å¤©æ°”ç±»å‹ï¼ˆæ™´ã€å¤šäº‘ã€å°é›¨â€¦ï¼‰ */
    const weatherType =
      w.weather || w.wxShort || w.main || w.type || "";

    /* æ¸©åº¦åŒºé—´ */
    const tMin = typeof w.tMin === "number" ? w.tMin : null;
    const tMax = typeof w.tMax === "number" ? w.tMax : null;

    /* ä¸­å¿ƒæ¸©åº¦ï¼ˆå‰ç«¯æœ€å¸¸ç”¨ï¼‰ */
    const midT = (tMin != null && tMax != null)
      ? Math.round((tMin + tMax) / 2)
      : (typeof w.midT === "number" ? w.midT : null);

    /* å®Œæ•´å‰¯æ ‡é¢˜ï¼ˆUI å·²ç»ç®—å¥½ï¼‰ */
    const desc = w.desc || w.summary || "";

    /* é»˜è®¤ä½¿ç”¨ km åæ¨æµ·æ‹” */
    const ele = (typeof w.ele === "number") ? w.ele : getEleAtKm(w.km);

    nodes.push({
      id: w.id || ("W" + (i + 1)),
      nodeType: "weather",

      startKm: w.km ?? null,
      endKm: w.km ?? null,

      startPt: { lat: w.lat ?? null, lon: w.lon ?? null, ele },
      endPt:   { lat: w.lat ?? null, lon: w.lon ?? null, ele },

      /* å‰ç«¯å¤©æ°”æ¡ç”¨ shortNameï¼šå¤šäº‘ 15Â° */
      shortName:
        (weatherType && midT != null)
          ? `${weatherType} ${midT}Â°`
          : (w.temp || weatherType || ""),

      /* title å‰ç«¯ä¸ç”¨ï¼Œç•™ç©ºå³å¯ */
      title: "",

      /* desc = é£/é™æ°´/UV/ä½“æ„Ÿ çš„æ•´ä¸²æ–‡æœ¬ */
      desc,

      tags: [],
      algo: "weather-v1",

      /* å‰ç«¯ JSON éœ€è¦çš„å¤©æ°”ç»“æ„ */
      data: {
        weatherType,     // å¤šäº‘
        temp: midT,      // 15
        tempMin: tMin,   // 13
        tempMax: tMax,   // 17
        feel: w.feel,
        wind: w.wind,
        pop: w.pop,
        uv: w.uv
      }
    });
  });
}


  /* ---- äººå·¥ï¼ˆmanualScenesï¼‰ â†’ nodes ---- */
  if (Array.isArray(G1_DATA.manualScenes)) {
    G1_DATA.manualScenes.forEach((msc, i) => {

      const sLat = parseFloat(msc.startLat);
      const sLon = parseFloat(msc.startLon);
      const eLat = parseFloat(msc.endLat);
      const eLon = parseFloat(msc.endLon);

      nodes.push({
        id: msc.id || ("M" + (i + 1)),
        nodeType: "manual",

        startKm: msc.startKm ?? null,
        endKm:   msc.endKm ?? null,
        positionKm: msc.startKm ?? null,   // â˜… æ–°å¢ï¼šæŠ½å±‰åˆ—è¡¨ä½ç½®

        startPt: {
          lat: isNaN(sLat) ? null : sLat,
          lon: isNaN(sLon) ? null : sLon,
          ele: msc.startEle ?? null
        },
        endPt: {
          lat: isNaN(eLat) ? null : eLat,
          lon: isNaN(eLon) ? null : eLon,
          ele: msc.endEle ?? null
        },

        shortName: msc.name || "",
        title: msc.name || "",
        desc: msc.desc || "",

        tags: (msc.tags && typeof msc.tags === "string")
          ? msc.tags.split(",").map(t => t.trim()).filter(t => t)
          : [],

        algo: "manual-v1",

        data: {
          lengthM: msc.lengthM ?? null,
          raw: msc.data || ""
        },

        media: msc.media || ""
      });
    });
  }

  return nodes;
}

/* ============================================================
   â­ Node Model é¢„è§ˆä¸æ–‡æ¡ˆç¼–è¾‘ï¼ˆä¸å½±å“ç°æœ‰å¯¼å‡ºé€»è¾‘ï¼‰
   ============================================================ */
let NODE_MODEL_PREVIEW = [];  // ä»…ç”¨äºé¢„è§ˆ & ä¸´æ—¶ç¼–è¾‘

// æ˜ å°„ nodeType â†’ ä¸­æ–‡
function mapNodeTypeToCN(t) {
  const map = {
    "terrain": "åœ°å½¢æ®µ",
    "weather": "å¤©æ°”èŠ‚ç‚¹",
    "manual": "äººå·¥èŠ‚ç‚¹",
    "hazard": "é£é™©èŠ‚ç‚¹",
    "facility": "è®¾æ–½èŠ‚ç‚¹",
    "ai_scene": "AI åœºæ™¯"
  };
  return map[t] || t;
}

// ========= å¯¼å‡º =========
/* ============================================================
   Step 3-A: ä¾æ®ç»çº¬åº¦åŒ¹é… profile æœ€è¿‘ç‚¹ï¼Œè¿”å› km / ele
============================================================ */
function snapToProfile(lat, lon, profile) {
    if (!profile || profile.length === 0) return { km: null, ele: null };

    let best = null;
    let bestDist = Infinity;

    profile.forEach(pt => {
        if (pt.lat == null || pt.lon == null) return;

        const dLat = pt.lat - lat;
        const dLon = pt.lon - lon;
        const distSq = dLat * dLat + dLon * dLon; // ä¸éœ€è¦çœŸå®è·ç¦»ï¼Œæ¯”è¾ƒå¹³æ–¹å³å¯

        if (distSq < bestDist) {
            bestDist = distSq;
            best = pt;
        }
    });

    return best ? { km: best.km, ele: best.ele } : { km: null, ele: null };
}

/* ============================================================
   â­ æŠŠ G1.meta çš„ç»Ÿè®¡å­—æ®µç»§æ‰¿åˆ° ROUTE_NODES.meta.stats
   - ä¸æ”¹å˜ä½ åŸæœ‰ meta å­—æ®µ
   - stats æ”¾åœ¨ meta.statsï¼Œé¿å…æ±¡æŸ“ node model
============================================================ */
function buildRouteMetaWithStats() {
  const base = {
    routeId: "",
    name: "",
    region: "",
    originalFile: "",
    startDate: null,
    tags: []
  };

  const m = (G1_DATA && G1_DATA.meta && typeof G1_DATA.meta === "object") ? G1_DATA.meta : {};
  const out = { ...base, ...m };

  // ä»…å½“ G1.meta é‡Œå­˜åœ¨è¿™äº›å­—æ®µæ—¶æ‰å†™å…¥ stats
  const hasAny = m && Object.keys(m).length > 0;


  if (hasAny) {
    out.stats = {
      distanceKm: (m.distanceKm != null && m.distanceKm !== "") ? Number(m.distanceKm) : null,
      maxEle:     (m.maxEle != null && m.maxEle !== "") ? Number(m.maxEle) : null,
      minEle:     (m.minEle != null && m.minEle !== "") ? Number(m.minEle) : null,
      ascent:     (m.ascent != null && m.ascent !== "") ? Number(m.ascent) : null,
      descent:    (m.descent != null && m.descent !== "") ? Number(m.descent) : null,
      source: "G1",
      updatedAt: new Date().toISOString()
    };

    // å…œåº•ï¼šå¦‚æœ distanceKm æ²¡æœ‰ï¼Œä½† profile æœ€åä¸€ä¸ªç‚¹æœ‰ kmï¼Œåˆ™ç”¨å®ƒè¡¥ä¸Š
    if ((out.stats.distanceKm == null) && Array.isArray(G1_DATA?.profile) && G1_DATA.profile.length) {
      const last = G1_DATA.profile[G1_DATA.profile.length - 1];
      if (typeof last.km === "number") out.stats.distanceKm = Number(last.km);
      // å¦‚æœæ˜¯ trackâ†’profile å…¼å®¹è¿‡æ¥çš„ cumDistï¼ˆç±³ï¼‰ï¼Œä¹Ÿåšå…œåº•
      if (out.stats.distanceKm == null && typeof last.cumDist === "number") {
        out.stats.distanceKm = Number((last.cumDist / 1000).toFixed(3));
      }
    }
  }

  return out;
}
// ===============================
// ä» G1_DATA.meta ç”Ÿæˆå¯¼å‡ºç”¨ meta
// ===============================
function buildRouteMetaFromG1() {
  const base = {
    routeId: "",
    name: "",
    region: "",
    originalFile: "",
    startDate: null,
    tags: []
  };

  if (!window.G1_DATA || !G1_DATA.meta) {
    return base;
  }

  const m = G1_DATA.meta;

  return {
    ...base,
    ...m,
    stats: {
      distanceKm: m.distanceKm != null ? Number(m.distanceKm) : null,
      maxEle:     m.maxEle     != null ? Number(m.maxEle)     : null,
      minEle:     m.minEle     != null ? Number(m.minEle)     : null,
      ascent:     m.ascent     != null ? Number(m.ascent)     : null,
      descent:    m.descent    != null ? Number(m.descent)    : null,
      source: "G1",
      updatedAt: new Date().toISOString()
    }
  };
}

/* ============================================================
   â­ Step 1ï¼šå¯¼å‡º Node Modelï¼ˆå”¯ä¸€æŒ‰é’®ï¼‰
   ============================================================ */
function exportNodeModel() {

syncManualScenesFromUI();
normalizeManualScenes();
  const out = {
        version: "1.6",
        generatedAt: new Date().toISOString(),
        meta: buildRouteMetaWithStats(),

        // è½¨è¿¹ï¼ˆprofileï¼‰
        profile: G1_DATA.profile || [],

        // åœ°å½¢æ®µï¼ˆsegmentsï¼‰
        segments: G1_DATA.segments || [],

        // å¤©æ°”èŠ‚ç‚¹ï¼ˆweatherNodesï¼‰
        weatherNodes: G1_DATA.weatherNodes || [],

        // äººå·¥åœºæ™¯ï¼ˆmanualScenesï¼‰
        manualScenes: G1_DATA.manualScenes || []
    };

    const blob = new Blob([JSON.stringify(out, null, 2)], {type: "application/json"});
    const url = URL.createObjectURL(blob);

    const a = document.createElement("a");
    a.href = url;
    a.download = "ROUTE_NODES.json";
    a.click();
    URL.revokeObjectURL(url);
}


// ========= ä¿å­˜è‰ç¨¿ =========
function saveDraft() {
  if (!G1_DATA) return alert("æ— å¯ä¿å­˜å†…å®¹ï¼Œè¯·å…ˆåŠ è½½ JSON");

    syncSegmentsFromUI();
  syncManualScenesFromUI();
  normalizeManualScenes();   // â˜… ä¿å­˜è‰ç¨¿æ—¶ä¹ŸæŠŠ km / ele è¡¥ä¸Š

  // â˜… æ–°å¢ï¼šè‰ç¨¿ä¹Ÿéœ€è¦åæ ‡å®Œæ•´æ€§æ ¡éªŒ
  if (!validateManualScenes()) return;


  localStorage.setItem("G1_EDITOR_DRAFT", JSON.stringify(G1_DATA));
  alert("è‰ç¨¿å·²ä¿å­˜");
}


// ========= æ¸…é™¤è‰ç¨¿ =========
function clearDraft() {
  localStorage.removeItem("G1_EDITOR_DRAFT");
  alert("è‰ç¨¿å·²æ¸…é™¤");
}
window.addEventListener("load", () => {

  // â˜…â˜…â˜…â˜…â˜… å…ˆæ£€æŸ¥æ˜¯å¦ä» G1 é¡µé¢å¸¦å…¥æ•°æ® â˜…â˜…â˜…â˜…â˜…
  const fromG1 = localStorage.getItem("G1_FROM_ANALYZER");
  if (fromG1) {
    try {
      G1_DATA = JSON.parse(fromG1);
      console.log("ğŸ”¥ æ¥è‡ª G1 çš„å®Œæ•´æ•°æ®ï¼š", G1_DATA);
      initDataAfterLoad();
      document.getElementById("loadStatus").innerHTML =
        "<span style='color:green'>âœ” å·²ä» G1 é¡µé¢è‡ªåŠ¨å¯¼å…¥</span>";
    } catch (e) {
      console.error("G1 æ•°æ®è§£æå¤±è´¥:", e);
    }

    // â˜… ç”¨å®Œå†åˆ ï¼ˆä¸èƒ½æå‰åˆ ï¼‰
    localStorage.removeItem("G1_FROM_ANALYZER");
    return;
  }

  // â˜…â˜…â˜…â˜…â˜… å¦åˆ™æ£€æŸ¥è‰ç¨¿ â˜…â˜…â˜…â˜…â˜…
  const draft = localStorage.getItem("G1_EDITOR_DRAFT");
  if (draft) {
    try {
      G1_DATA = JSON.parse(draft);
      console.log("ğŸŸ§ æ¢å¤è‰ç¨¿ï¼š", G1_DATA);
      initDataAfterLoad();
      document.getElementById("loadStatus").innerHTML =
        "<span style='color:orange'>âœ” å·²ä»è‰ç¨¿è‡ªåŠ¨æ¢å¤</span>";
    } catch (e) {
      console.error("è‰ç¨¿åŠ è½½å¤±è´¥:", e);
    }
  }
});
/* ============================================================
   SegmentManager â€” åœ°å½¢æ®µè‡ªåŠ¨åŠ©æ‰‹ï¼ˆç­–ç•¥ Cï¼‰
   ============================================================ */

const SegmentManager = {

  /* ---------- æ‰¾å‡ºæŸä¸ª km åº”è¯¥å±äºå“ªä¸€æ®µ ---------- */
  findSegmentIndexAtKm(km, segments) {
    for (let i = 0; i < segments.length; i++) {
      const s = segments[i];
      if (km >= s.startKm && km <= s.endKm) return i;
    }
    return -1;
  },

  /* ---------- è‡ªåŠ¨åˆ†è£‚æ®µ ---------- */
  insertSegmentAtKm(km, newSeg) {
    const segs = G1_DATA.segments;
    const idx = this.findSegmentIndexAtKm(km, segs);

    if (idx < 0) {
      alert("âš ï¸ æ— æ³•æ’å…¥åœ°å½¢æ®µï¼šè¯¥ä½ç½®ä¸åœ¨ä»»ä½•ç°æœ‰åœ°å½¢æ®µå†…ï¼");
      return false;
    }

    const target = segs[idx];

    // ä¸èƒ½åœ¨æ®µé¦–æˆ–æ®µå°¾ 10m å†…æ’å…¥
    if (Math.abs(km - target.startKm) < 0.01 ||
        Math.abs(km - target.endKm) < 0.01) {
      alert("âš ï¸ æ’å…¥ä½ç½®å¤ªé è¿‘æ®µè¾¹ç•Œï¼Œè¯·åœ¨ä¸­é—´ä½ç½®é€‰æ‹©ï¼");
      return false;
    }

    // â€”â€” åˆ†è£‚ â€”â€” //
    const segA = {
      ...target,
      endKm: km
    };

    const segB = {
      id: "NEW",
      type: "äººå·¥åœ°å½¢",
      title: newSeg.title || "äººå·¥æ–°å¢",
      subtitle: "",
      startKm: km,
      endKm: km + 0.05,
      startPt: newSeg.startPt,
      endPt: newSeg.endPt
    };

    const segC = {
      ...target,
      startKm: km
    };

    // æ›¿æ¢åŸæ®µ â†’ æ’å…¥æ–°æ®µ
    segs.splice(idx, 1, segA, segB, segC);
    this.reindex();

    return true;
  },

  /* ---------- åˆ é™¤æ®µï¼ˆè‡ªåŠ¨åˆå¹¶ç›¸é‚»æ®µï¼‰ ---------- */
  deleteSegment(i) {
    const segs = G1_DATA.segments;

    if (i === 0 || i === segs.length - 1) {
      alert("âš ï¸ é¦–å°¾æ®µä¸èƒ½åˆ é™¤ï¼ˆä¿æŒè·¯çº¿è¿ç»­æ€§ï¼‰");
      return false;
    }

    const prev = segs[i - 1];
    const next = segs[i + 1];

    // åˆå¹¶ï¼šå‰æ®µ + åæ®µ
    prev.endKm = next.endKm;
    prev.endPt = next.endPt;

    segs.splice(i, 2);
    this.reindex();
    return true;
  },

  /* ---------- ä¿®æ”¹æ®µæ—¶çš„æ‹“æ‰‘æ ¡éªŒ ---------- */
  validateTopology(i) {
    const segs = G1_DATA.segments;
    const seg = segs[i];
    const prev = segs[i - 1];
    const next = segs[i + 1];

    if (seg.startKm >= seg.endKm) {
      alert("âš ï¸ èµ·ç‚¹å¿…é¡»å°äºç»ˆç‚¹ï¼");
      return false;
    }

    // ä¸Šæ®µä¸èƒ½è¶…è¿‡æœ¬æ®µèµ·ç‚¹
    if (prev && prev.endKm > seg.startKm) {
      const diff = prev.endKm - seg.startKm;
      if (diff > 0.2) {
        alert("âš ï¸ è°ƒæ•´è¿‡å¤§ï¼Œä¼šä¸ä¸Šä¸€æ®µé‡å ï¼");
        return false;
      }
      prev.endKm = seg.startKm;
    }

    // ä¸‹æ®µä¸èƒ½æ—©äºæœ¬æ®µç»ˆç‚¹
    if (next && next.startKm < seg.endKm) {
      const diff = seg.endKm - next.startKm;
      if (diff > 0.2) {
        alert("âš ï¸ è°ƒæ•´è¿‡å¤§ï¼Œä¼šä¸ä¸‹ä¸€æ®µé‡å ï¼");
        return false;
      }
      next.startKm = seg.endKm;
    }

    return true;
  },

  /* ---------- é‡æ–°ç¼–å· ---------- */
  reindex() {
    G1_DATA.segments.forEach((s, i) => {
      s.id = "T" + (i + 1);
    });
  }
};


</script>   



</body>
</html>
