<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<title>Route Builder â€” G1 è½¨è¿¹è§£æ</title>

<style>
body{
  font-family:Arial,Helvetica,sans-serif;
  background:#f4f4f4;margin:0;padding:20px;
}
h1{margin-bottom:30px;}
h2{margin-top:30px;}
.box{
  background:#fff;padding:20px;border-radius:10px;
  margin-bottom:30px;border:1px solid:#ddd;
}
table{
  width:100%;border-collapse:collapse;margin-top:15px;font-size:14px;
}
td,th{
  border:1px solid:#ccc;padding:6px;text-align:left;
}
.meta{
  white-space:pre-line;background:#fafafa;padding:10px;
  border-radius:8px;border:1px solid:#ccc;
}
.btn{
  padding:8px 16px;background:#007bff;border:none;color:#fff;
  border-radius:6px;margin-right:10px;cursor:pointer;font-size:14px;
}
/* è½¨è¿¹æ¨¡å¼æŒ‰é’®è¢«é€‰ä¸­æ—¶çš„æ ·å¼ */
.clean-selected{
  box-shadow:0 0 0 2px rgba(0,0,0,0.35) inset;
  transform:scale(1.02);
}
.scene-box{
  border:1px solid:#ccc;border-radius:12px;padding:15px;
  margin-bottom:15px;background:#fff;
}
.note{
  font-size:12px;color:#555;margin-top:8px;
}
#progressContainer{
  margin-top:10px;height:10px;background:#eee;border-radius:5px;
  overflow:hidden;display:none;
}
#progressBar{
  height:100%;width:0;background:#007bff;
  transition:width 0.2s;
}

/* Stepper æ ·å¼ */
.stepper {
  display: flex;
  align-items: center;
  background: #fff;
  padding: 16px 20px;
  border-bottom: 1px solid #e5e5e5;
  margin-bottom: 15px;
}

.step { display:flex; align-items:center; }
.step .circle {
  width: 26px; height: 26px;
  border-radius: 50%;
  background: #ccc; color: #fff;
  display:flex; align-items:center; justify-content:center;
  margin-right: 8px; font-size: 13px;
}
.step.active .circle { background:#1a73e8; }
.step .label { font-size:14px; color:#666; }
.step.active .label { color:#1a73e8; font-weight:bold; }

.line {
  flex:1; height:1px; background:#ddd; margin:0 12px;
}

/* éšè— G2/G3 åŒºåŸŸ */
.hide { display:none !important; }

</style>
<!-- Leaflet æ ·å¼ -->
<link
  rel="stylesheet"
  href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
/>

<!-- Leaflet è„šæœ¬ -->
<script
  src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js">
</script>

</head>

<body>

<!-- Stepper -->
<div class="stepper">
  <div class="step active">
    <span class="circle">1</span>
    <span class="label">G1 â€” è½¨è¿¹è§£æ</span>
  </div>
  <div class="line"></div>

  <div class="step">
    <span class="circle">2</span>
    <span class="label">G2 â€” å¤–éƒ¨ä¿¡æ¯è·å–</span>
  </div>
  <div class="line"></div>

  <div class="step">
    <span class="circle">3</span>
    <span class="label">G3 â€” åœºæ™¯æ°”æ³¡ç”Ÿæˆ</span>
  </div>
</div>

<h1>Route Builder â€” G1 è½¨è¿¹è§£æ</h1>

<!-- Step 1 -->
<div class="box">
  <h2>Step 1ï½œä¸Šä¼ è½¨è¿¹ (GPX/KML) + é€‰æ‹©æ—¥æœŸ</h2>
  <input type="file" id="fileInput">
 <input type="date" id="dateInput" value="">
  <button class="btn" onclick="parseTrack()">è§£æè½¨è¿¹</button>
  <div id="routeName" class="meta"></div>
<div id="routeRegion" class="meta"></div>
  <div id="meta" class="meta"></div>
  <!-- ========== æ–°å¢ï¼šè½¨è¿¹é¢„è§ˆåœ°å›¾ï¼ˆå¯è§†åŒ–åŸå§‹/æ¸…æ´—å¯¹æ¯”ï¼‰ ========== -->
<div id="trackPreviewBox" style="margin-top:15px;">
  <h3 style="font-size:14px;margin-bottom:6px;">è½¨è¿¹é¢„è§ˆï¼ˆåŸå§‹ / æ¸…æ´—å¯¹æ¯”ï¼‰</h3>

  <div id="trackMap" style="
    width:100%;
    height:260px;
    border-radius:8px;
    overflow:hidden;
    border:1px solid #ccc;
  "></div>

  <div style="margin-top:10px; display:flex; gap:10px;">
  <button id="btnShowRaw"  class="btn btn-sm" style="background:#d9534f;">åŸå§‹è½¨è¿¹</button>
  <button id="btnShowL1"   class="btn btn-sm" style="background:#5cb85c;">Level-1 æ¸…æ´—</button>
  <button id="btnShowL2"   class="btn btn-sm" style="background:#0275d8;">Level-2 æ·±åº¦æ¸…æ´—</button>
<div id="pointStats" style="margin-top:8px; font-size:13px; color:#333;">
  <!-- ä¸‰ä¸ªæ•°å­—ä¼šè‡ªåŠ¨å¡«è¿›å» -->
</div>


</div>

</div>

<!-- Step 2ï¼ˆG1ï¼‰ -->
<div class="box">
  <h2>Step 2ï½œç”Ÿæˆè‡ªç„¶åˆ†æ®µï¼ˆå¤©æ°” / åœ°å½¢ / åœ°è²Œï¼‰</h2>

  <!-- ç”Ÿæˆ G1 -->
  <button class="btn" onclick="buildG1()">ç”Ÿæˆè‡ªç„¶åˆ†æ®µ</button>

  <div id="progressContainer">
    <div id="progressBar"></div>
  </div>
  <div id="progressText" class="note"></div>

  <!-- â˜… æ–°æŒ‰é’®ï¼šå¯¼å‡º JSON -->
  <button id="openEditorBtn" class="btn" style="margin-top:10px;">è¿›å…¥äººå·¥ç¼–è¾‘å™¨</button>
<button id="downloadJsonBtn" class="btn" style="margin-top:10px; margin-left:10px;">ä¸‹è½½ JSON</button>

  <!-- G1 æŠ¥å‘Šè¾“å‡ºä½ç½® -->
  <div id="g1"></div>
</div>

<!-- éšè—æ—§ G2 / G3 -->
<div class="hide">
  <div id="g2"></div>
  <div id="scenes"></div>
</div>



<!-- åº•éƒ¨æ“ä½œ -->
<div style="display:flex; justify-content:flex-end; margin-top:40px;">
  <button class="btn" style="background:#666;" onclick="alert('G1 ä¿å­˜æˆåŠŸ')">ä¿å­˜</button>
  <button class="btn" onclick="window.location.href='G2.html'">ä¸‹ä¸€æ­¥ â†’</button>
</div>

<!-- ä½ çš„æ‰€æœ‰ JS é€»è¾‘ä¿æŒä¸å˜ï¼Œä¸åŠ¨ä»»ä½•ä¸€è¡Œ -->
<script>
// æ­¤å¤„è‡ªåŠ¨ä¿ç•™ä½ åŸæœ¬çš„æ‰€æœ‰é€»è¾‘ï¼ˆè§£æè½¨è¿¹ã€G1ã€G2ã€åœºæ™¯ç­‰ï¼‰
// æˆ‘ä¸ä¼šä¿®æ”¹ä½ çš„ä»»ä½•å‡½æ•°
</script>
</body>
</html>


<script>


//-----------------------------------------------------
// å·¥å…·ï¼šHaversine è·ç¦»
//-----------------------------------------------------
function dist(lat1,lon1,lat2,lon2){
  const R=6371000;
  const toRad=x=>x*Math.PI/180;
  const dLat=toRad(lat2-lat1);
  const dLon=toRad(lon2-lon1);
  const a =
    Math.sin(dLat/2)**2 +
    Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
  return 2*R*Math.asin(Math.sqrt(a));
}
//-----------------------------------------------------
// ã€ç¬¬ 1 å°æ­¥ã€‘ç»Ÿä¸€ 7 å¤§ç±»åˆ†æ®µçš„å ä½å‡½æ•°ï¼ˆä¸ä¼šè¢«è°ƒç”¨ï¼Œä¸å½±å“ç°æœ‰åŠŸèƒ½ï¼‰
// ç”¨äºæœªæ¥åŠ¨æ€ç”Ÿæˆï¼šåœ°å½¢ / åœ°è²Œ / æ¤è¢« / è·¯é¢ / è®¾æ–½ / æ™¯è§‚æ–‡åŒ– / å¤©æ°”
//-----------------------------------------------------
function buildUnifiedSegments() {
  return {
    topography: [],     // 2.1 åœ°å½¢
    geomorphology: [],  // 2.2 åœ°è²Œ
    vegetation: [],     // 2.3 æ¤è¢«
    surface: [],        // 3 è·¯é¢
    facilities: [],     // 4 è®¾æ–½
    culture: [],        // 5 æ™¯è§‚æ–‡åŒ–
    weather: []         // 7 å¤©æ°”ï¼ˆå…³é”®ç‚¹æˆ–åŒºé—´ï¼‰
  };
}

//-----------------------------------------------------
// ç»Ÿä¸€çš„åˆ†æ®µç»“æ„
//-----------------------------------------------------
function createSegmentItem(params){
  return {
    id: params.id || "",
    startKm: params.startKm || 0,
    endKm: params.endKm || 0,
    startEle: params.startEle || 0,
    endEle: params.endEle || 0,
    label: params.label || "",
    desc: params.desc || "",
    startPt: params.startPt || null,
    endPt: params.endPt || null,
    source: params.source || ""
  };
}
//-----------------------------------------------------
// ã€ç¬¬ 2 å°æ­¥ã€‘åŠ¨æ€ç”Ÿæˆåˆ†æ®µç‚¹ï¼ˆä»…åˆ›å»ºï¼Œä¸å‚ä¸ä»»ä½•å®é™…é€»è¾‘ï¼‰
//-----------------------------------------------------
function computeRouteBreakpoints(trackPoints) {

  if (!trackPoints || trackPoints.length < 2) {
    return { mode: "short", points: [] };
  }

  // èµ·ç‚¹ (P0) ä¸ç»ˆç‚¹ (P_end)
  const P0 = trackPoints[0];
  const P_end = trackPoints[trackPoints.length - 1];

  // è®¡ç®—æ€»è·ç¦»ä¸æµ·æ‹”å·®
  let totalDist = 0;
  for (let i = 1; i < trackPoints.length; i++) {
    const d = dist(
      trackPoints[i - 1].lat, trackPoints[i - 1].lng,
      trackPoints[i].lat, trackPoints[i].lng
    );
    totalDist += d;
  }

  const totalEleGain = Math.abs(P_end.ele - P0.ele);

  // åˆ¤å®š 3 æ®µ or 5 æ®µ
  const isLongRoute = (totalDist > 10) || (totalEleGain > 1000);

  let breakpoints = [];

  if (!isLongRoute) {
    //-----------------------------------------------------
    // 3 æ®µï¼šP0 â†’ P2(æœ€é«˜ç‚¹) â†’ P_end
    //-----------------------------------------------------
    const highestIdx = findHighestPointIndex(trackPoints);
    const P2 = trackPoints[highestIdx];

    breakpoints = [
      { id: "P0", pt: P0, km: 0 },
      { id: "P2_highest", pt: P2, km: P2.cumDist/1000 },
      { id: "P_end", pt: P_end, km: totalDist/1000 }
    ];

    return { mode: "short", points: breakpoints };
  }

  //-----------------------------------------------------
  // 5 æ®µï¼šP0 â†’ P1(1/3) â†’ P2æœ€é«˜ç‚¹ â†’ P3(2/3) â†’ P_end
  //-----------------------------------------------------
  const P1 = getPointAtDistance(trackPoints, totalDist * 0.333);
  const highestIdx = findHighestPointIndex(trackPoints);
  const P2 = trackPoints[highestIdx];
  const P3 = getPointAtDistance(trackPoints, totalDist * 0.666);

  breakpoints = [
    { id: "P0", pt: P0, km: 0 },
    { id: "P1_33", pt: P1, km: P1.cumDist/1000 },
    { id: "P2_highest", pt: P2, km: P2.cumDist/1000 },
    { id: "P3_66", pt: P3, km: P3.cumDist/1000 },
    { id: "P_end", pt: P_end, km: totalDist/1000 }
  ];

  return { mode: "long", points: breakpoints };
}

//-----------------------------------------------------
// æ‰¾æœ€é«˜ç‚¹
//-----------------------------------------------------
function findHighestPointIndex(track) {
  let idx = 0;
  let maxEle = -99999;
  for (let i = 0; i < track.length; i++) {
    if (track[i].ele > maxEle) {
      maxEle = track[i].ele;
      idx = i;
    }
  }
  return idx;
}

//-----------------------------------------------------
// æŒ‰è·ç¦»å¯»æ‰¾å¯¹åº”è½¨è¿¹ç‚¹
//-----------------------------------------------------
function getPointAtDistance(track, targetDist) {
  let acc = 0;
  for (let i = 1; i < track.length; i++) {
    let d = dist(
      track[i - 1].lat, track[i - 1].lng,
      track[i].lat, track[i].lng
    );
    if (acc + d >= targetDist) {
      return track[i];
    }
    acc += d;
  }
  return track[track.length - 1];
}
//-----------------------------------------------------
// ã€ç¬¬ 3 å°æ­¥ã€‘ç»Ÿä¸€ 7 å¤§ç±»æ®µè½ç»“æ„å®¹å™¨
//-----------------------------------------------------
function buildUnifiedCategoryContainer() {
  return {
    weather: [],         // å¤©æ°”
    topography: [],      // åœ°å½¢
    geomorphology: [],   // åœ°è²Œ
    vegetation: [],      // æ¤è¢«
    surface: [],         // è·¯é¢
    facilities: [],      // è®¾æ–½
    culture: []          // æ™¯è§‚æ–‡åŒ–
  };
}

//-----------------------------------------------------
// åˆ›å»ºç»Ÿä¸€æ®µè½å¯¹è±¡æ¨¡æ¿
//-----------------------------------------------------
function createUnifiedSegment(id, startKm, endKm, startEle, endEle, label, desc, startPt, endPt, source) {
  return {
    id: id || "",
    startKm: startKm || 0,
    endKm: endKm || 0,
    startEle: startEle || 0,
    endEle: endEle || 0,
    label: label || "",
    desc: desc || "",
    startPt: startPt || null,
    endPt: endPt || null,
    source: source || ""
  };
}
//-----------------------------------------------------
// ã€ç¬¬ 4 å°æ­¥ã€‘æ ¹æ®åˆ†æ®µç‚¹ç”Ÿæˆç»Ÿä¸€æ ¼å¼ç©ºæ®µè½
//-----------------------------------------------------
function buildEmptyUnifiedSegments(breakpointResult) {
  if (!breakpointResult || !breakpointResult.points || breakpointResult.points.length < 2) {
    return [];
  }

  const pts = breakpointResult.points;  // P0~P2~P_end
  let segments = [];

  for (let i = 0; i < pts.length - 1; i++) {

    // è‡ªåŠ¨ç”Ÿæˆç¼–å·ï¼ˆS1, S2, S3â€¦ï¼‰
    let id = "S" + (i + 1);

    let startKm = pts[i].km;
    let endKm   = pts[i+1].km;

    // æµ·æ‹”åŒºé—´
    let startEle = pts[i].pt.ele;
    let endEle   = pts[i + 1].pt.ele;

    // èµ·ç‚¹ä¸ç»ˆç‚¹åæ ‡
    let startPt = pts[i].pt;
    let endPt   = pts[i + 1].pt;

    let seg = createUnifiedSegment(
      id,
      startKm,
      endKm,
      startEle,
      endEle,
      "",   // label
      "",   // desc
      startPt,
      endPt,
      ""    // source
    );

    segments.push(seg);
  }

  return segments;
}

//-------------------------------------------------------------
// A. åˆ†æ®µç‚¹è®¡ç®—ï¼ˆç”¨äº 3 æ®µ / 5 æ®µï¼‰â€”â€”ä¸Šé¢å·²ç»å®šä¹‰ï¼Œè¿™é‡Œä¿ç•™ä¸€ä»½å…¼å®¹
//-------------------------------------------------------------


//-------------------------------------------------------------
// B. ç»Ÿä¸€æ®µè½æ¨¡æ¿ + ç±»åˆ«å®¹å™¨ â€”â€” ä¸Šé¢å·²æœ‰ï¼Œæ­¤å¤„ä¿æŒåŒåå®ç°
//-------------------------------------------------------------


//-------------------------------------------------------------
// C. å°†åˆ†æ®µç‚¹è½¬æ¢æˆç»Ÿä¸€æ®µè½æ¡†æ¶ï¼ˆç©ºæ®µè½ï¼‰â€”â€”åŒä¸Š
//-------------------------------------------------------------
//-----------------------------------------------------
// â˜… æ–°å¢ï¼šè‡ªç„¶åˆ†æ®µ JSON å…¨å±€ç¼“å­˜
//-----------------------------------------------------
window._G1_EXPORT_JSON = null;

// -----------------------------------------------------
// å…¨å±€æ•°æ®
// -----------------------------------------------------
let trackPoints = [];      // æ¸…æ´—åçš„è½¨è¿¹ï¼ˆä¸‹æ¸¸æ‰€æœ‰ç®—æ³•ç»§ç»­ç”¨è¿™ä¸ªï¼‰
let rawTrackPoints = [];   // åŸå§‹è½¨è¿¹ï¼ˆä»…åšå¤‡ä»½ï¼Œä¸å‚ä¸è®¡ç®—ï¼‰

let totalDist = 0;
let ascent    = 0;
let descent   = 0;
let minEle    = Infinity;
let maxEle    = -Infinity;

let g1Segments   = [];
let weatherZones = []; // Z1â€“Z? å½“å¤©å¤©æ°”å…³é”®ç‚¹
// Level-1 / Level-2 å¤‡ä»½ï¼ˆå¯¹è±¡æ•°ç»„ï¼‰
let l1TrackPoints = [];   // Level-1 æ¸…æ´—åçš„è½¨è¿¹å¯¹è±¡
let l2TrackPoints = [];   // Level-2 æ·±åº¦æ¸…æ´—åçš„è½¨è¿¹å¯¹è±¡ï¼ˆæ ¹æ® L1 æ„é€ ï¼‰
// â˜… ç»™å¯¼å‡º JSON ç”¨çš„å…¨å±€å ä½ï¼Œé¿å…æœªå®šä¹‰é”™è¯¯
let vegSeg = [];       // æ¤è¢«æ®µ
let facilities = [];   // è®¾æ–½åˆ—è¡¨ï¼ˆæš‚æ—¶å¯ä»¥ä¸ºç©ºï¼‰

// å½“å‰è¢«é€‰ä¸­ç”¨äºåç»­åˆ†æçš„è½¨è¿¹æ¨¡å¼ï¼šraw | l1 | l2
window._currentTrackMode = "l1";

//-----------------------------------------------------
// ç»Ÿä¸€ 7 å¤§ç±»å®¹å™¨
//-----------------------------------------------------
let unified7 = {
  weather:    [],
  geomorph:   [],
  vegetation: [],
  surface:    [],
  facility:   [],
  culture:    [],
  summary:    []
};
// ======================================
// TopoSeg 4.0 â€” ç§‘å­¦å¢å¼ºç‰ˆï¼ˆè¶‹åŠ¿æŒç»­æ€§ + æ›²ç‡ + ç²—ç³™åº¦ï¼‰
// ä¸å½±å“ä½ çš„ä»»ä½•å…¶ä»–é€»è¾‘å­—æ®µ
// ======================================
function topoSeg20(points) {

    if (!points || points.length < 2) return [];

    // --------------------------------------
    // åœ°çƒè·ç¦»
    // --------------------------------------
    function d(a, b) {
        const R = 6371000;
        if (!a || !b) return 0;
        const dLat = (b.lat - a.lat) * Math.PI / 180;
        const dLon = (b.lon - a.lon) * Math.PI / 180;
        const lat1 = a.lat * Math.PI / 180;
        const lat2 = b.lat * Math.PI / 180;
        const h = Math.sin(dLat/2)**2 +
                  Math.cos(lat1)*Math.cos(lat2)*Math.sin(dLon/2)**2;
        return 2 * R * Math.asin(Math.sqrt(h));
    }

    // --------------------------------------
    // ç´¯è®¡è·ç¦»
    // --------------------------------------
    points[0].cumDist = 0;
    for (let i = 1; i < points.length; i++) {
        points[i].cumDist = points[i-1].cumDist + d(points[i], points[i-1]);
    }

    const totalDist = points[points.length - 1].cumDist;

    // --------------------------------------
    // åŠ¨æ€ç›®æ ‡è·ç¦»ï¼ˆä¿æŒä½ çš„åŸé€»è¾‘ï¼‰
    // --------------------------------------
    let WINDOW = 40;
    if (totalDist < 6000) WINDOW = 20;
    else if (totalDist < 15000) WINDOW = 30;
    else if (totalDist < 30000) WINDOW = 40;
    else WINDOW = 50;

    // ======================================
    // â‘  å›ºå®šè·ç¦»è¶‹åŠ¿ï¼šæœ€è¿‘ç‚¹è¶‹åŠ¿ï¼ˆåŸºçº¿ï¼‰
    // ======================================
    function trendSlope(i) {
        const target = points[i].cumDist + WINDOW;

        let bestJ = i;
        let bestDiff = Infinity;

        for (let j = i + 1; j < points.length; j++) {
            const diff = Math.abs(points[j].cumDist - target);
            if (diff < bestDiff) {
                bestDiff = diff;
                bestJ = j;
            }
            if (points[j].cumDist - points[i].cumDist > WINDOW * 2) break;
        }

        const dist = points[bestJ].cumDist - points[i].cumDist;
        if (dist <= 0) return 0;

        const dh = points[bestJ].ele - points[i].ele;
        return dh / dist * 100;
    }

    let slopeArr = points.map((_, i) => trendSlope(i));

    // ======================================
    // â‘¡ è¶‹åŠ¿æŒç»­æ€§ä¿®æ­£ï¼ˆSlope Persistenceï¼‰
    // ======================================
    for (let i = 2; i < slopeArr.length; i++) {
        const prev = slopeArr[i - 1];
        const curr = slopeArr[i];

        // å¦‚æœæ–¹å‘çªå˜ã€ä¸”å¹…åº¦æ›´å° â†’ åˆ¤å®šä¸ºå™ªå£° â†’ å¹³æ»‘åˆ°å‰ä¸€ä¸ªè¶‹åŠ¿
        if (Math.sign(curr) !== Math.sign(prev) && Math.abs(curr) < Math.abs(prev)) {
            slopeArr[i] = prev * 0.9;  // ä¿ç•™ä¸€ç‚¹è¡°å‡
        }
    }

    // ======================================
    // â‘¢ åœ°å½¢æ›²ç‡ï¼ˆCurvatureï¼‰å¢å¼ºè¶‹åŠ¿
    // ======================================
    function curvature(i) {
        if (i <= 0 || i >= points.length - 1) return 0;
        return points[i+1].ele + points[i-1].ele - 2 * points[i].ele;
    }

    for (let i = 1; i < slopeArr.length - 1; i++) {
        const curv = curvature(i);

        if (curv > 1) {
            // å‡¹å¡ï¼ˆå¡åº•ï¼‰ â†’ çœŸå®è¶‹åŠ¿æ¯”è¡¨é¢çœ‹èµ·æ¥æ›´é™¡
            slopeArr[i] *= 1.15;
        } 
        else if (curv < -1) {
            // å‡¸å¡ï¼ˆå¡é¡¶ï¼‰ â†’ è¶‹åŠ¿åº”å‡å¼±
            slopeArr[i] *= 0.85;
        }
    }

    // ======================================
    // â‘£ åœ°å½¢ç²—ç³™åº¦ TRI â†’ è‡ªé€‚åº” MIN_LEN
    // ======================================
    function localTRI(i) {
        let arr = [];
        for (let k = -5; k <= 5; k++) {
            if (points[i + k]) arr.push(points[i + k].ele);
        }
        if (arr.length < 3) return 0;
        const mean = arr.reduce((s, v) => s + v, 0) / arr.length;
        const variance = arr.reduce((s, v) => s + (v - mean) ** 2, 0) / arr.length;
        return Math.sqrt(variance);
    }

    let TRI = 0;
    for (let i = 0; i < points.length; i += 10) {
        TRI += localTRI(i);
    }
    TRI /= (points.length / 10);

    // TRI é«˜ = åœ°å½¢ç²—ç³™ â†’ MIN_LEN æ›´é•¿
    let TRI_FACTOR = 1 + Math.min(TRI / 30, 0.5); // æœ€å¤§å¢åŠ  50%

    // åŸå§‹ MIN_LEN é€»è¾‘ï¼ˆä¿ç•™ï¼‰
    let change = 0;
    for (let i = 1; i < slopeArr.length; i++) {
        if (Math.sign(slopeArr[i]) !== Math.sign(slopeArr[i-1])) change++;
    }
    const changeRate = change / slopeArr.length;

    let MIN_LEN = WINDOW * 2;
    if (changeRate > 0.25) MIN_LEN = WINDOW * 3;
    if (changeRate > 0.35) MIN_LEN = WINDOW * 4;

    MIN_LEN *= TRI_FACTOR; // åŠ å…¥åœ°å½¢ç²—ç³™å› ç´ 

    // --------------------------------------
    // ä¸‰ç‚¹å¹³æ»‘ï¼ˆä¿ç•™ï¼‰
    // --------------------------------------
    slopeArr = slopeArr.map((_, i) => {
        let a = slopeArr[i-1] ?? slopeArr[i];
        let b = slopeArr[i];
        let c = slopeArr[i+1] ?? slopeArr[i];
        return (a+b+c)/3;
    });

    // --------------------------------------
    // æµ·æ‹”æ•æ„Ÿåº¦ï¼ˆä¿ç•™ï¼‰
    // --------------------------------------
    const avgEle = points.reduce((s,p)=>s+p.ele,0)/points.length;
    let SLOPE_FACTOR = 1;
    if (avgEle > 3000) SLOPE_FACTOR = 1.5;
    else if (avgEle > 1500) SLOPE_FACTOR = 1.2;

    // --------------------------------------
    // UIAA å¡åº¦åˆ†ç±»ï¼ˆä¿ç•™ï¼‰
    // --------------------------------------
    function slopeClass(rawPct) {
        const pct = rawPct / SLOPE_FACTOR;
        const deg = Math.atan(pct / 100) * 57.3;

        if (deg > 25) return "æé™¡ä¸Šå¡";
        if (deg > 15) return "é™¡ä¸Šå¡";
        if (deg > 5)  return "ç¼“ä¸Šå¡";

        if (deg < -25) return "æé™¡ä¸‹å¡";
        if (deg < -15) return "é™¡ä¸‹å¡";
        if (deg < -5)  return "ç¼“ä¸‹å¡";

        return "å¹³ç¼“è·¯";
    }

    // --------------------------------------
    // STEP1ï¼šåˆ‡æ®µï¼ˆä¿ç•™ï¼‰
    // --------------------------------------
    let rawSegs = [];
    let s = 0;
    let cur = slopeClass(slopeArr[0]);

    for (let i = 1; i < slopeArr.length; i++) {
        const t = slopeClass(slopeArr[i]);
        if (t !== cur) {
            rawSegs.push({ start: s, end: i-1, type: cur });
            s = i;
            cur = t;
        }
    }
    rawSegs.push({ start: s, end: slopeArr.length-1, type: cur });

    // --------------------------------------
    // STEP2ï¼šçŸ­æ®µè¿‡æ»¤ï¼ˆä¿ç•™+TRIå¢å¼ºï¼‰
    // --------------------------------------
    let stage2 = [];
    for (let seg of rawSegs) {
        const len = points[seg.end].cumDist - points[seg.start].cumDist;
        if (len < MIN_LEN) {
            if (stage2.length)
                stage2[stage2.length-1].end = seg.end;
        } else stage2.push(seg);
    }

    // --------------------------------------
    // STEP3ï¼šåˆå¹¶ï¼ˆä¿ç•™ï¼‰
    // --------------------------------------
    let merged = [];
    for (let seg of stage2) {
        if (merged.length && merged[merged.length-1].type === seg.type)
            merged[merged.length-1].end = seg.end;
        else
            merged.push({ ...seg });
    }

    // --------------------------------------
    // STEP4ï¼šè¾“å‡ºï¼ˆå®Œå…¨ä¿æŒä½ çš„ç»“æ„ï¼‰
    // --------------------------------------
    let out = [];

    for (let seg of merged) {
        const startPt = points[seg.start];
        const endPt   = points[seg.end];

        const dist = endPt.cumDist - startPt.cumDist;
        const delta = endPt.ele - startPt.ele;

        const pct = (delta / dist) * 100;
        const deg = Math.atan(delta / dist) * 57.3;

        const desc =
            `æŒç»­ ${Math.round(dist)} mï½œ` +
            `é«˜å·® ${delta >= 0 ? "+" + delta : delta} mï½œ` +
            `æ–œç‡ ${pct.toFixed(1)}%ï½œ` +
            `å¡åº¦ ${deg.toFixed(1)}Â°`;

        out.push({
            startKm: startPt.cumDist / 1000,
            endKm:   endPt.cumDist / 1000,

            startPt,
            endPt,

            deltaEle: Math.round(delta),
            slopePct: Number(pct.toFixed(1)),
            slopeClass: seg.type,
            type: seg.type,
            title: seg.type,
            description: desc
        });
    }

    return out;
}

async function reverseGeocode(lat, lon){
  const url = `https://nominatim.openstreetmap.org/reverse?lat=${lat}&lon=${lon}&format=json&zoom=5&accept-language=zh`;

  try{
    const res = await fetch(url, { headers:{ "User-Agent":"RouteBuilder/1.0" } });
    if(!res.ok) throw new Error("RG fail");

    const data = await res.json();
    return data.address.country || "æœªçŸ¥åœ°åŒº";
  }catch(e){
    console.warn("åå‘åœ°ç†ç¼–ç å¤±è´¥", e);
    return "æœªçŸ¥åœ°åŒº";
  }
}
// -----------------------------------------------------
// â˜…â˜… æ ¹æ®è½¨è¿¹ç‚¹æ•°ç»„ trackPoints å–å¾—ä¸­ç‚¹åæ ‡ï¼ˆç”¨äºå›½å®¶è¯†åˆ«ï¼‰
// -----------------------------------------------------
function getTrackCenterFromPoints(){
  if (!Array.isArray(trackPoints) || trackPoints.length === 0) return null;
  const mid = trackPoints[Math.floor(trackPoints.length / 2)];
  return { lat: mid.lat, lon: mid.lon };
}

// -----------------------------------------------------
// â˜…â˜… è‡ªåŠ¨æå–è½¨è¿¹åç§°ï¼ˆä¼˜å…ˆè¯»å– GPX/KML å†…éƒ¨ï¼‰
// -----------------------------------------------------
function extractTrackName(text, fileName){
  // â‘  GPX <name>
  let g = text.match(/<name>(.*?)<\/name>/i);
  if (g && g[1] && g[1].trim().length > 0){
    return g[1].trim();
  }

  // â‘¡ KML <Document><name>
  let k = text.match(/<Document>[\s\S]*?<name>(.*?)<\/name>/i);
  if (k && k[1] && k[1].trim().length > 0){
    return k[1].trim();
  }

  // â‘¢ fallbackï¼šæ–‡ä»¶åï¼ˆå»æ‰©å±•åï¼‰
  if (fileName){
    return fileName.replace(/\.(gpx|kml)$/i, "");
  }

  return "æœªå‘½åè½¨è¿¹";
}



// -----------------------------------------------------
// â˜…â˜… ä»è½¨è¿¹ profile ä¸­å–å¾—ä¸­ç‚¹åæ ‡ï¼ˆç”¨äºå›½å®¶è¯†åˆ«ï¼‰
// -----------------------------------------------------
function getTrackCenter(profile){
  if (!Array.isArray(profile) || profile.length === 0){
    return null;
  }
  const mid = profile[Math.floor(profile.length / 2)];
  return { lat: mid.lat, lon: mid.lon };
}



//-----------------------------------------------------
// å°å·¥å…·ï¼šåæ ‡ â†’ OSM åœ°å›¾é“¾æ¥
//-----------------------------------------------------
function mapUrl(p){
  return `https://www.openstreetmap.org/?mlat=${p.lat}&mlon=${p.lon}&zoom=14`;
}
function fmtCoord(p){ return `${p.lat.toFixed(5)}, ${p.lon.toFixed(5)}`; }

//-----------------------------------------------------
// Step1ï¼šè§£æ GPX / KML
//-----------------------------------------------------
function parseTrack(){
  const file=document.getElementById("fileInput").files[0];
  // è‡ªåŠ¨æå–è½¨è¿¹åç§°ï¼ˆæ— æ‰©å±•åï¼‰
const baseName = file.name.replace(/\.(gpx|kml)$/i,"");
document.getElementById("routeName").textContent = "è½¨è¿¹åç§°ï¼š" + baseName;

  if(!file){ alert("è¯·ä¸Šä¼  GPX/KML æ–‡ä»¶"); return; }

  const reader=new FileReader();
  reader.onload = async e => {
  const text = e.target.result;

  // â˜… è‡ªåŠ¨æå–è½¨è¿¹åç§°ï¼ˆå†…éƒ¨ <name> ä¼˜å…ˆï¼‰
  const fileName = file.name;
  const displayName = extractTrackName(text, fileName);
  document.getElementById("routeName").textContent = "è½¨è¿¹åç§°ï¼š" + displayName;

// â˜… å¼€å§‹è§£æè½¨è¿¹
parseKMLorGPX(text);

// â˜… Level-1ï¼šåŸºç¡€æ¸…æ´—ï¼ˆä½ åŸæ¥çš„ postProcessTrackï¼‰
postProcessTrack();


// â˜… ç»™é¢„è§ˆåœ°å›¾å‡†å¤‡æ•°æ®ï¼ˆæ³¨æ„è½¬æ¢ä¸º [lat, lon]ï¼‰
const rawSource = (Array.isArray(rawTrackPoints) && rawTrackPoints.length)
  ? rawTrackPoints        // æœ‰å¤‡ä»½å°±ç”¨åŸå§‹
  : trackPoints;          // å¦åˆ™é€€åŒ–ä¸ºæ¸…æ´—ç»“æœ

  window.G1_RAW_TRACK   = rawSource.map(p   => [p.lat, p.lon]);
  window.G1_CLEAN_TRACK = trackPoints.map(p => [p.lat, p.lon]);
  window.G1_L2_TRACK    = null;           // æ¯æ¬¡é‡æ–°è§£æéƒ½æ¸…ç©º L2 ç¼“å­˜

  // é»˜è®¤ä½¿ç”¨ Level-1 æ¸…æ´—è½¨è¿¹
  previewCleanedTrack(window.G1_CLEAN_TRACK);
  setActiveTrackMode("l1");






// â˜… æ¸…æ´—å®Œæˆåå†æ ¹æ®è½¨è¿¹ä¸­ç‚¹åæŸ¥å›½å®¶ï¼ˆä¸ä¼šå½±å“ä»»ä½•é€»è¾‘ï¼‰
const center = getTrackCenterFromPoints();
if (center){
  const country = await reverseGeocode(center.lat, center.lon);
  const box = document.getElementById("countryName");  
  if (box){
    box.textContent = "å›½å®¶/åœ°åŒºï¼š" + country;
  }
}


  // â˜… åŸæœ¬çš„æ˜¾ç¤ºé€»è¾‘å®Œå…¨ä¿ç•™
  showMeta();
  document.getElementById("g1").innerHTML="";
  document.getElementById("g2").innerHTML="";
  document.getElementById("scenes").innerHTML="";
  g1Segments=[];
  weatherZones=[];
};

  reader.readAsText(file);
}

function parseKMLorGPX(text){
  trackPoints=[];
  totalDist=0; ascent=0; descent=0;
  minEle=Infinity; maxEle=-Infinity;

  const xml=new DOMParser().parseFromString(text,"application/xml");

  // GPX ä¼˜å…ˆ
  let pts=[...xml.getElementsByTagName("trkpt")];
  if(pts.length>0){
    let cum=0;
    pts.forEach((pt,i)=>{
      const lat=parseFloat(pt.getAttribute("lat"));
      const lon=parseFloat(pt.getAttribute("lon"));
      const eleNode=pt.getElementsByTagName("ele")[0];
      const ele=eleNode?parseFloat(eleNode.textContent):0;
      const timeNode=pt.getElementsByTagName("time")[0];
      const time=timeNode?new Date(timeNode.textContent):null;

      if(i>0){
        const prev=trackPoints[i-1];
        const d=dist(prev.lat,prev.lon,lat,lon);
        cum+=d;
        totalDist+=d;
        const gain=ele-prev.ele;
        if(gain>0) ascent+=gain; else descent+=(-gain);
      }
      if(ele<minEle)minEle=ele;
      if(ele>maxEle)maxEle=ele;
      trackPoints.push({lat,lon,ele,cumDist:cum,time});
    });
    return;
  }

  // KML <coordinates>
  const coords=xml.getElementsByTagName("coordinates");
  let arr=[];
  for(let c of coords){
    const lines=c.textContent.trim().split(/\s+/);
    for(let ln of lines){
      const sp=ln.split(",");
      if(sp.length>=2){
        arr.push({
          lon:parseFloat(sp[0]),
          lat:parseFloat(sp[1]),
          ele:sp[2]?parseFloat(sp[2]):0
        });
      }
    }
  }
  let cum=0;
  for(let i=0;i<arr.length;i++){
    const p=arr[i];
    if(i>0){
      const prev=trackPoints[i-1];
      const d=dist(prev.lat,prev.lon,p.lat,p.lon);
      cum+=d;
      totalDist+=d;
      const gain=p.ele-prev.ele;
      if(gain>0) ascent+=gain; else descent+=(-gain);
    }
    if(p.ele<minEle)minEle=p.ele;
    if(p.ele>maxEle)maxEle=p.ele;
    trackPoints.push({lat:p.lat,lon:p.lon,ele:p.ele,cumDist:cum,time:null});
  }
  window.trackPoints = trackPoints;
}
//-----------------------------------------------------
// è½¨è¿¹æ¸…æ´—æ€»å…¥å£ï¼šä¿å­˜åŸå§‹è½¨è¿¹ + å»å°–åˆº + é‡æ–°ç»Ÿè®¡
//-----------------------------------------------------
//-----------------------------------------------------
// è½¨è¿¹æ¸…æ´—æ€»å…¥å£ï¼šä¿å­˜åŸå§‹è½¨è¿¹ + å»å°–åˆº + æµ·æ‹”å¹³æ»‘ + é‡æ–°ç»Ÿè®¡
//-----------------------------------------------------
function postProcessTrack() {
  if (!Array.isArray(trackPoints) || trackPoints.length < 2) {
    return;
  }

  // 1ï¼‰å¤‡ä»½åŸå§‹ç‚¹
  rawTrackPoints = trackPoints.map(p => ({ ...p }));

  // 2ï¼‰æ‰§è¡Œæ¸…æ´—ï¼ˆå°–åˆºè¿‡æ»¤ï¼‰
  const result = cleanTrack(rawTrackPoints);

  // 3ï¼‰è½»åº¦å¹³æ»‘ï¼ˆMA 3 ç‚¹ï¼‰
  result.points = smoothElevationMA(result.points);

  // é‡æ–°ç»Ÿè®¡ï¼ˆå› ä¸ºå¹³æ»‘åçš„ ele å˜äº†ï¼‰
  const finalStats = recomputeStats(result.points);

  // 4ï¼‰å›å†™åˆ°å…¨å±€
  trackPoints = finalStats.points;
  totalDist   = finalStats.totalDist;
  ascent      = finalStats.ascent;
  descent     = finalStats.descent;
  minEle      = finalStats.minEle;
  maxEle      = finalStats.maxEle;

  // é¢å¤–ä¿å­˜ä¸€ä»½ Level-1 æ¸…æ´—åçš„åŸå§‹å¯¹è±¡
  l1TrackPoints = finalStats.points.map(p => ({ ...p }));

  // 5ï¼‰ç»™ UI ç”¨çš„å·®å¼‚æ•°æ®
  window._cleanReport = {
    before: rawTrackPoints.length,
    after: finalStats.points.length,
    removed: rawTrackPoints.length - finalStats.points.length
  };

  console.log("âœ… è½¨è¿¹æ¸…æ´—å®Œæˆï¼šåŸå§‹ç‚¹", window._cleanReport.before, 
              "â†’ æ¸…æ´—å", window._cleanReport.after);
           // =====================================================
  // â­ æœ€ç»ˆæƒå¨ç»Ÿè®¡ç»“æœ â†’ å†™å›å…¨å±€ï¼ˆä¾› export ä½¿ç”¨ï¼‰
  // =====================================================
  let _dist = 0;
  let _asc = 0;
  let _desc = 0;
  let _minEle = null;
  let _maxEle = null;

  for (let i = 1; i < trackPoints.length; i++) {
    const p0 = trackPoints[i - 1];
    const p1 = trackPoints[i];

    const d = dist(p0.lat, p0.lon, p1.lat, p1.lon);
    _dist += d;

    const gain = p1.ele - p0.ele;
    if (gain > 0) _asc += gain;
    else _desc += -gain;

    if (_minEle === null || p1.ele < _minEle) _minEle = p1.ele;
    if (_maxEle === null || p1.ele > _maxEle) _maxEle = p1.ele;
  }

  // ğŸ‘‰ å†™å›å…¨å±€ï¼Œä½œä¸ºå”¯ä¸€å¯ä¿¡ç»Ÿè®¡æº
  window.totalDist = _dist;
  window.ascent    = _asc;
  window.descent   = _desc;
  window.minEle    = _minEle;
  window.maxEle    = _maxEle;
  window.trackPoints = trackPoints;     
}


//-----------------------------------------------------
// æ ¸å¿ƒæ¸…æ´—ç®—æ³•ï¼šå»æ‰ GPS é£˜ç‚¹ / ç¬ç§»å°–åˆºï¼Œå¹¶é‡æ–°è®¡ç®—ç»Ÿè®¡
//-----------------------------------------------------
function cleanTrack(rawPoints) {
  if (!Array.isArray(rawPoints) || rawPoints.length < 2) {
    return {
      points: rawPoints.slice(),
      totalDist: totalDist,
      ascent: ascent,
      descent: descent,
      minEle: minEle,
      maxEle: maxEle
    };
  }

  // å…è®¸çš„æœ€å¤§é€Ÿåº¦ï¼ˆm/sï¼‰å’Œæœ€å¤§å•æ®µè·³è·ƒï¼ˆmï¼‰
  // å¯¹äºå¾’æ­¥æ¥è¯´ï¼Œ> 12 m/s (~43 km/h) åŸºæœ¬ä¸å¯èƒ½
  const MAX_SPEED = 12;
  const MAX_JUMP  = 200;

  const cleaned = [];
  cleaned.push({ ...rawPoints[0] });

  for (let i = 1; i < rawPoints.length; i++) {
    const prev = cleaned[cleaned.length - 1];
    const cur  = rawPoints[i];

    const d = dist(prev.lat, prev.lon, cur.lat, cur.lon); // m

    let ok = true;

    // 1ï¼‰è·ç¦»ç‰¹åˆ«å¤§çš„è·³è·ƒï¼Œç›´æ¥è®¤å®šä¸ºé£˜ç‚¹
    if (d > MAX_JUMP) {
      ok = false;
    }

    // 2ï¼‰å¦‚æœæœ‰æ—¶é—´æˆ³ï¼Œç®—ä¸€ä¸‹é€Ÿåº¦ï¼Œå¤ªå¿«ä¹Ÿè®¤ä¸ºæ˜¯å¼‚å¸¸
    if (ok && prev.time && cur.time && cur.time instanceof Date && prev.time instanceof Date) {
      const dtSec = (cur.time - prev.time) / 1000;
      if (dtSec > 0) {
        const v = d / dtSec; // m/s
        if (v > MAX_SPEED) {
          ok = false;
        }
      }
    }

    if (ok) {
      cleaned.push({ ...cur });
    } else {
      // ä»…åšè®°å½•ï¼Œä¸æ‰“æ‰° UI
      console.log("âš ï¸ ç§»é™¤å¼‚å¸¸ç‚¹ï¼ˆé£˜ç‚¹/ç¬ç§»ï¼‰:", {
        index: i,
        lat: cur.lat,
        lon: cur.lon,
        distFromPrev: d.toFixed(1)
      });
    }
  }

  // è‡³å°‘éœ€è¦ 2 ä¸ªç‚¹
  if (cleaned.length < 2) {
    // é˜²å¾¡ï¼šå¦‚æœå…¨è¢«åˆ å…‰äº†ï¼Œå°±é€€å›åŸå§‹
    return {
      points: rawPoints.slice(),
      totalDist: totalDist,
      ascent: ascent,
      descent: descent,
      minEle: minEle,
      maxEle: maxEle
    };
  }

  // é‡æ–°è®¡ç®— cumDist / totalDist / ascent / descent / minEle / maxEle
  let cum = 0;
  let tDist = 0;
  let asc = 0;
  let desc = 0;
  let minE = Infinity;
  let maxE = -Infinity;

  cleaned[0].cumDist = 0;

  for (let i = 1; i < cleaned.length; i++) {
    const prev = cleaned[i - 1];
    const cur  = cleaned[i];

    const d = dist(prev.lat, prev.lon, cur.lat, cur.lon);
    cum += d;
    tDist += d;

    const gain = cur.ele - prev.ele;
    if (gain > 0) asc += gain;
    else          desc += (-gain);

    cur.cumDist = cum;
  }

  cleaned.forEach(p => {
    if (p.ele < minE) minE = p.ele;
    if (p.ele > maxE) maxE = p.ele;
  });

  return {
    points: cleaned,
    totalDist: tDist,
    ascent: asc,
    descent: desc,
    minEle: minE,
    maxEle: maxE
  };
}
//-----------------------------------------------------
// è½»åº¦æµ·æ‹”å¹³æ»‘ï¼šç§»åŠ¨å¹³å‡ MA (3-point)
//-----------------------------------------------------
function smoothElevationMA(points) {
  if (points.length < 3) return points;

  const out = points.map(p => ({ ...p })); // clone

  for (let i = 1; i < points.length - 1; i++) {
    out[i].ele = (
      points[i - 1].ele +
      points[i].ele +
      points[i + 1].ele
    ) / 3;
  }

  return out;
}
//-----------------------------------------------------
// å¹³æ»‘åé‡æ–°ç»Ÿè®¡è·ç¦»/æµ·æ‹”ç´¯ç§¯
//-----------------------------------------------------
function recomputeStats(points) {
  let cum = 0, asc = 0, desc = 0;
  let minE = Infinity, maxE = -Infinity;

  const out = [];
  out.push({ ...points[0], cumDist: 0 });

  for (let i = 1; i < points.length; i++) {
    const prev = out[i - 1];
    const cur = points[i];

    const d = dist(prev.lat, prev.lon, cur.lat, cur.lon);
    cum += d;

    const gain = cur.ele - prev.ele;
    if (gain > 0) asc += gain;
    else          desc += (-gain);

    out.push({ ...cur, cumDist: cum });

    if (cur.ele < minE) minE = cur.ele;
    if (cur.ele > maxE) maxE = cur.ele;
  }

  return {
    points: out,
    totalDist: cum,
    ascent: asc,
    descent: desc,
    minEle: minE,
    maxEle: maxE
  };
}

//-----------------------------------------------------
// åŸºæœ¬ä¿¡æ¯
//-----------------------------------------------------
function showMeta(){
  if(trackPoints.length<2){
    document.getElementById("meta").textContent="è½¨è¿¹ç‚¹è¿‡å°‘ï¼Œæ— æ³•åˆ†æã€‚";
    return;
  }
  const kmTotal=totalDist/1000;
  const asc=Math.round(ascent);
  const desc=Math.round(descent);
  const start=trackPoints[0];
  const end=trackPoints[trackPoints.length-1];

  let durationText="æœªçŸ¥ï¼ˆç¼ºå°‘æ—¶é—´æˆ³ï¼‰";
  const withTime=trackPoints.filter(p=>p.time);
  if(withTime.length>=2){
    const t0=withTime[0].time;
    const t1=withTime[withTime.length-1].time;
    const h=(t1-t0)/3600000;
    if(h>0) durationText=h.toFixed(2)+" h";
  }

  const startLink = mapUrl(start);
  const endLink   = mapUrl(end);

  document.getElementById("meta").innerHTML=
`è½¨è¿¹ç‚¹æ•°ï¼š${trackPoints.length}
æ€»è·ç¦»ï¼š${kmTotal.toFixed(2)} km
ç´¯è®¡ä¸Šå‡ï¼š${asc} m
ç´¯è®¡ä¸‹é™ï¼š${desc} m
æœ€ä½æµ·æ‹”ï¼š${Math.round(minEle)} m
æœ€é«˜æµ·æ‹”ï¼š${Math.round(maxEle)} m
èµ·ç‚¹åæ ‡ï¼š${fmtCoord(start)}
ç»ˆç‚¹åæ ‡ï¼š${fmtCoord(end)}
è®°å½•æ—¶é•¿ï¼ˆè‹¥è½¨è¿¹å¸¦æ—¶é—´ï¼‰ï¼š${durationText}

èµ·ç‚¹åœ°å›¾ï¼š<a href="${startLink}" target="_blank">åœ¨åœ°å›¾ä¸­æŸ¥çœ‹</a>
ç»ˆç‚¹åœ°å›¾ï¼š<a href="${endLink}" target="_blank">åœ¨åœ°å›¾ä¸­æŸ¥çœ‹</a>`;
}
// æ˜¾ç¤ºæ¸…æ´—å·®å¼‚
if (window._cleanReport) {
  box.innerHTML += `
    <br>åŸå§‹ç‚¹æ•°ï¼š${window._cleanReport.before}
    <br>æ¸…æ´—åç‚¹æ•°ï¼š${window._cleanReport.after}
    <br>ç§»é™¤å¼‚å¸¸ç‚¹ï¼š${window._cleanReport.removed}
  `;
}

//-----------------------------------------------------
// km â†’ æ’å€¼
//-----------------------------------------------------
function interpKm(km){
  const target=km*1000;
  if(target<=0) return trackPoints[0];
  if(target>=totalDist) return trackPoints[trackPoints.length-1];

  for(let i=1;i<trackPoints.length;i++){
    const prev=trackPoints[i-1];
    const cur =trackPoints[i];
    if(cur.cumDist>=target){
      const span=cur.cumDist-prev.cumDist || 1;
      const r=(target-prev.cumDist)/span;
      return {
        lat: prev.lat + r*(cur.lat-prev.lat),
        lon: prev.lon + r*(cur.lon-prev.lon),
        ele: prev.ele + r*(cur.ele-prev.ele),
        cumDist: target
      };
    }
  }
  return trackPoints[trackPoints.length-1];
}


//-----------------------------------------------------
// å¤–éƒ¨æ•°æ®ï¼šOSM å‘¨è¾¹é“è·¯ä¸è®¾æ–½ï¼ˆå·²å…³é—­ OSM è¯·æ±‚ï¼‰
//-----------------------------------------------------
async function queryOSMContext(lat, lon) {
  // ä¸è¿›è¡Œä»»ä½•å¤–éƒ¨ API è°ƒç”¨ï¼Œé¿å… 429 / 504 æŠ¥é”™
  console.log("OSM æŸ¥è¯¢å·²å…³é—­ï¼šqueryOSMContext è¿”å› null");
  return null;
}

//-----------------------------------------------------
// å¤–éƒ¨æ•°æ®ï¼šWikidata æ–‡åŒ– / åœ°åï¼ˆå·²å…³é—­å¤–éƒ¨æŸ¥è¯¢ï¼‰
//-----------------------------------------------------
async function queryWikidataContext(lat, lon) {
  console.log("Wikidata æŸ¥è¯¢å·²å…³é—­ï¼šqueryWikidataContext è¿”å› []");
  return [];
}


//-----------------------------------------------------
// ä» OSM JSON ä¸­æå–è·¯é¢ / è®¾æ–½æ‘˜è¦
//-----------------------------------------------------
function summarizeOSM(data) {
  if (!data) {
    return {
      surface: "è‡ªç„¶å±±è·¯ / è·¯é¢ä¿¡æ¯æœªçŸ¥",
      facilities: []
    };
  }
  const elements = data.elements || [];
  let surface = null;
  const facilities = [];

  for (const el of elements) {
    if (el.type === "way" && el.tags) {
      if (!surface && el.tags.surface) {
        surface = el.tags.surface;
      }
    }
    if (el.type === "node" && el.tags) {
      const t = el.tags;
      if (t.tourism || t.amenity) {
        const name = t.name || t.tourism || t.amenity;
        facilities.push(name);
      }
    }
  }

  let surfaceText = "è‡ªç„¶å±±è·¯ / æ··åˆè·¯é¢";
  if (surface) {
    if (surface.includes("gravel")) surfaceText = "ç¢çŸ³è·¯é¢ï¼ˆgravelï¼‰";
    else if (surface.includes("rock")) surfaceText = "å²©çŸ³è·¯é¢";
    else if (surface.includes("paved")) surfaceText = "ç¡¬åŒ–è·¯é¢";
    else if (surface.includes("dirt") || surface.includes("ground")) surfaceText = "åœŸè·¯è·¯é¢";
    else surfaceText = "è·¯é¢ï¼š" + surface;
  }

  return {
    surface: surfaceText,
    facilities
  };
}

//-----------------------------------------------------
// åˆ†ç±»å·¥å…·ï¼šæµ·æ‹”å¸¦ + å¡åº¦ + åœ°è²Œæ–‡å­—
//-----------------------------------------------------
function altBandLabel(ele){
  if(ele < 800)   return "æ²³è°· / ä¸˜é™µåœ°å¸¦ï¼šå†œç”°ã€ç‰§åœºæˆ–çŒä¸›ï¼‹é˜”å¶æ—ä¸ºä¸»";
  if(ele < 1600)  return "å±±åœ°æ—ç¼˜ï¼šé’ˆé˜”æ··äº¤æ—ã€å³¡è°·æ£®æ—æˆ–å±±è°·è‰å¡";
  if(ele < 2600)  return "é«˜å±±è‰ç”¸ï¼šçŸ®çŒä¸›ï¼‹è‰ç”¸ï¼Œæ ‘çº¿é™„è¿‘çš„å¼€é˜”å¡é¢";
  if(ele < 3600)  return "é«˜å±±ç¢çŸ³å¡ï¼šç¨€ç–æ¤è¢«ï¼‹ç¢çŸ³/å²©å¡ï¼Œæ¥è¿‘é›ªçº¿åŒºåŸŸ";
  return "æé«˜å±±è£¸å²© / å†°é›ªåŒºï¼šå¤šä¸ºè£¸å²©ã€å†°é›ªè¦†ç›–ï¼Œæ¤è¢«æå°‘";
}

function classifySlope(deltaEle, distKm){
  if(distKm<=0) return {label:"å¡åº¦æœªçŸ¥", pct:0};
  const pct=(deltaEle/(distKm*1000))*100;
  let label;
  if(pct>=15)        label="é™¡å‡é•¿å¡";
  else if(pct>=8)   label="æŒç»­çˆ¬å‡æ®µ";
  else if(pct>=3)   label="ç¼“å‡å¡ / å°é˜¶çŠ¶ä¸Šå‡";
  else if(pct>-3)   label="è¿‘ä¹å¹³ç¼“çš„å°èµ·ä¼";
  else if(pct>-8)   label="ç¼“é™å¡";
  else if(pct>-15)  label="ä¸­ç­‰ä¸‹å¡";
  else              label="é™¡é™å¡ / ä¸‹åˆ‡è°·åœ°";
  return {label,pct:Math.round(pct*10)/10};
}

// æµ·æ‹” + å¡åº¦ â†’ åœºæ™¯åŒ–åœ°è²Œæè¿°
function geomorphDesc(meanEle, slopeLabel){
  if(meanEle < 800){
    if(slopeLabel.includes("é™¡é™")) return "ä¸‹åˆ‡å±±è°·æˆ–å³¡è°·è¾¹ç¼˜å°è·¯";
    if(slopeLabel.includes("é™¡å‡")) return "ä¸˜é™µä¸Šå¡ï¼Œå¯èƒ½æ˜¯åœŸè·¯æˆ–å°é˜¶ç™»é«˜";
    return "æ²³è°·/ä¸˜é™µåœ°å¸¦ï¼Œèµ·ä¼ä¸å¤§ï¼Œè§†é‡éšå¼€é˜”/æ ‘æœ¨å˜åŒ–";
  }
  if(meanEle < 1600){
    if(slopeLabel.includes("æŒç»­çˆ¬å‡")) return "å±±åœ°æ£®æ—æˆ–å³¡è°·ä¸­æŒç»­ä¸Šå‡è·¯æ®µ";
    if(slopeLabel.includes("é™¡é™")) return "æ—ä¸­ä¸‹å¡ï¼Œå¯èƒ½ç¢çŸ³/æ ‘æ ¹è·¯ï¼Œè¦æ³¨æ„è„šä¸‹";
    return "å±±åœ°æ—ç¼˜ã€æ£®æ—å°å¾„ï¼Œå¡åº¦æ¸©å’Œï¼Œç©¿è¡Œäºæ ‘æ—ä¸è§†é‡é—´";
  }
  if(meanEle < 2600){
    if(slopeLabel.includes("æŒç»­çˆ¬å‡")) return "é«˜å±±è‰ç”¸å‘ä¸Šçˆ¬å‡ï¼Œè§†é‡æ¸å¼€ï¼Œé£æ›´æ˜æ˜¾";
    if(slopeLabel.includes("é™¡é™")) return "é«˜å±±è‰ç”¸æˆ–çŸ®çŒä¸­çš„ä¸‹é™æ®µï¼Œè§†é‡å¼€é˜”ä½†éœ€æ³¨æ„è†ç›–å‹åŠ›";
    return "é«˜å±±è‰ç”¸ / çŸ®çŒå¡é¢ï¼Œè§†é‡è¾ƒå¼€é˜”ï¼Œå‘¨å›´å¤šä¸ºè‰ç”¸ä¸ä½çŸ®æ¤ç‰©";
  }
  if(meanEle < 3600){
    if(slopeLabel.includes("æŒç»­çˆ¬å‡")) return "ç¢çŸ³å¡æˆ–å²©å¡æ”€å‡ï¼Œæµ·æ‹”è¾ƒé«˜ï¼Œæ­¥ä¼éœ€ç¨³";
    if(slopeLabel.includes("é™¡é™")) return "é«˜å±±ç¢çŸ³/å²©å¡ä¸‹é™æ®µï¼Œå¡åº¦è¾ƒå¤§ï¼Œæ³¨æ„è½çŸ³ä¸ç«™ä½";
    return "é«˜å±±ç¢çŸ³å¸¦ï¼Œå²©çŸ³çªå‡ºï¼Œæ¤è¢«ç¨€ç–ï¼Œç¯å¢ƒåç²—çŠ·";
  }
  if(slopeLabel.includes("æŒç»­çˆ¬å‡")) return "æ¥è¿‘é›ªçº¿æˆ–å†°é›ªåŒºçš„æ”€å‡è·¯æ®µï¼Œç¯å¢ƒä¸¥é…·";
  if(slopeLabel.includes("é™¡é™")) return "å†°é›ª/è£¸å²©é«˜å¤„çš„ä¸‹é™æ®µï¼Œéœ€è¦é«˜åº¦ä¸“æ³¨ä¸é˜²æ»‘";
  return "æé«˜å±±è£¸å²©æˆ–å†°é›ªåŒºåŸŸï¼Œæ¤è¢«æå°‘ï¼Œå¤©æ°”ä¸è·¯å†µéƒ½åæç«¯";
}

///-----------------------------------------------------
// å¯¹å•ä¸ª G æ®µåšæ‰©å±•åˆ†æï¼ˆå·²å…³é—­ OSM / Wikidataï¼‰
//-----------------------------------------------------
async function analyzeSegmentExt(seg){
  
  // ä¿ç•™åŸæ¥ä½ çœŸæ­£éœ€è¦çš„ï¼šæ¤è¢«å¸¦æ¨¡å‹
  const vegetation = altBandLabel(seg.midPt ? seg.midPt.ele : 0);

  // æ ¹æ® G æ®µå¡åº¦å¾—å‡ºçš„é£é™©ï¼ˆä¸ä¾èµ– OSMï¼‰
  const hazards = [];
  if (Math.abs(seg.slopePct) >= 25) {
    hazards.push("é™¡å¡é£é™©ï¼ˆå¡åº¦ â‰¥25%ï¼‰");
  }
  if (seg.slopeLabel && seg.slopeLabel.includes("é™¡é™")) {
    hazards.push("ä¸‹å¡è†ç›–å‹åŠ›å¤§ï¼Œéœ€æ§åˆ¶é€Ÿåº¦");
  }

  return {
    vegetation,
    surface: "è‡ªç„¶å±±è·¯ / è·¯é¢ä¿¡æ¯æœªçŸ¥",
    hazards: hazards.length ? hazards.join("ï¼›") : "æš‚æ— æ˜æ˜¾å±é™©ç‰¹å¾ï¼ˆä»éœ€æ ¹æ®ç°åœºæƒ…å†µåˆ¤æ–­ï¼‰",
    culture: "é™„è¿‘æ— æ˜æ˜¾æ–‡åŒ–/åœ°åæ¡ç›®",
    facilities: [],
    sources: {
      osm: "å¤–éƒ¨æŸ¥è¯¢å·²å…³é—­",
      wikidata: "å¤–éƒ¨æŸ¥è¯¢å·²å…³é—­",
      model: "æµ·æ‹”å¸¦æ¨¡å‹ + å¡åº¦é˜ˆå€¼ï¼ˆ25%ï¼‰"
    },
    formulas: [
      "å¡åº¦ = Î”h / Î”s Ã— 100%",
      "å±é™©åˆ¤å®šï¼š|å¡åº¦| â‰¥25% â†’ é™¡å¡é£é™©",
      "æ¤è¢«å¸¦ï¼šæŒ‰æµ·æ‹”åˆ†å¸¦ï¼ˆæ²³è°·/å±±åœ°æ—ç¼˜/é«˜å±±è‰ç”¸/ç¢çŸ³å¸¦/å†°é›ªå¸¦ï¼‰"
    ]
  };
}


//-----------------------------------------------------
// G1 å½“æ—¥å¤©æ°”ï¼ˆæœ€ç»ˆä¼˜åŒ–ç‰ˆï¼‰
// æ¸©åº¦ï¼šå…¨éƒ¨å››èˆäº”å…¥ä¸ºæ•´æ•°
// summaryï¼šç®€ç§° + æ¸©åº¦åŒºé—´ï¼ˆå¦‚ â€œå¤šäº‘ï½œ-3â€“1â„ƒâ€ï¼‰
//-----------------------------------------------------
async function fetchDailyWeather(lat, lon, dateStr){
  const url =
    `https://api.open-meteo.com/v1/forecast` +
    `?latitude=${lat}&longitude=${lon}` +
    `&daily=weathercode,temperature_2m_max,temperature_2m_min,precipitation_probability_max,uv_index_max` +
    `&current_weather=true&timezone=auto&start_date=${dateStr}&end_date=${dateStr}`;

  const res = await fetch(url);
  if(!res.ok) throw new Error("å¤©æ°”æ¥å£è¯·æ±‚å¤±è´¥");

  const data = await res.json();
  const code = data.daily.weathercode[0];
  const wx   = dailyWeatherText(code);

  return {
    code,
    fullText: wx.full,
    short: wx.short,

    tmin: Math.round(data.daily.temperature_2m_min[0]),
    tmax: Math.round(data.daily.temperature_2m_max[0]),

    pop: data.daily.precipitation_probability_max[0],
    uv: Number(data.daily.uv_index_max[0].toFixed(1)),
    wind: Math.round(data.current_weather ? data.current_weather.windspeed : 3),

    // â˜…â˜…â˜… å…³é”®ï¼šæ¨¡å‹æµ·æ‹”åŸºå‡†ï¼ˆOpen-Meteo ç½‘æ ¼åœ°è¡¨é«˜åº¦ï¼‰
    modelElevation: data.elevation ?? 0
  };
}



//-----------------------------------------------------
// weathercode â†’ ä¸­æ–‡æè¿°ï¼ˆfull + shortï¼‰
//-----------------------------------------------------
function dailyWeatherText(code){
  switch(code){
    case 0:  return { full:"æ™´æœ—ï¼ŒåŸºæœ¬æ— äº‘", short:"æ™´" };
    case 1:  return { full:"ä»¥æ™´ä¸ºä¸»ï¼Œå¶æœ‰å°‘é‡äº‘", short:"æ™´é—´å¤šäº‘" };
    case 2:  return { full:"å¤šäº‘ï¼Œé—´æœ‰é˜³å…‰", short:"å¤šäº‘" };
    case 3:  return { full:"é˜´å¤©ä¸ºä¸»", short:"é˜´" };

    case 45:
    case 48: return { full:"æœ‰é›¾æˆ–é›¾å‡‡", short:"é›¾" };

    case 51:
    case 53:
    case 55: return { full:"å°é›¨æˆ–æ¯›æ¯›é›¨", short:"å°é›¨" };

    case 61:
    case 63:
    case 65: return { full:"ä¸­åˆ°æ˜æ˜¾é™é›¨", short:"ä¸­é›¨" };

    case 66:
    case 67: return { full:"å†»é›¨æˆ–å†°ç²’", short:"å†»é›¨" };

    case 71:
    case 73:
    case 75: return { full:"å°åˆ°ä¸­é›ª", short:"å°é›ª" };

    case 77: return { full:"é›ªç²’ / é›ªé˜µ", short:"é˜µé›ª" };

    // â˜… è¿™é‡Œä¿®æ­£ï¼šæ¯ä¸ª case åé¢éƒ½ç”¨å†’å·ï¼Œä¸è¦é€—å·
    case 80:
    case 81:
    case 82: return { full:"é˜µæ€§é™é›¨", short:"é˜µé›¨" };

    case 85:
    case 86: return { full:"é˜µæ€§é™é›ª", short:"é˜µé›ª" };

    case 95:
    case 96:
    case 97:
    case 98:
    case 99:
      return { full:"é›·é˜µé›¨æˆ–ä¼´å†°é›¹çš„å¼ºå¯¹æµ", short:"é›·é˜µé›¨" };

    default:
      return { full:"å¤©æ°”æƒ…å†µä¸æ˜", short:"ä¸æ˜" };
  }
}



//-----------------------------------------------------
// å¤©æ°”å…³é”®ç‚¹ï¼ˆç»ˆæ UI ç‰ˆï¼‰
//-----------------------------------------------------
async function buildWeatherKeyPoints(dateStr){
  const kmTotal = totalDist / 1000;
  const start   = trackPoints[0];
  const end     = trackPoints[trackPoints.length-1];

  // æœ€é«˜ç‚¹
  let highest = trackPoints.reduce((a,b)=> a.ele > b.ele ? a : b);

  const halfKm  = kmTotal / 2;
  const quarter = kmTotal / 4;
  const threeQ  = kmTotal * 3 / 4;

  const p25  = interpKm(quarter);
  const p50  = interpKm(halfKm);
  const p75  = interpKm(threeQ);
  const highKm = highest.cumDist / 1000;

  const candidates = [
    { label:"èµ·ç‚¹", km:0, p:start },
    { label:"å‰åŠç¨‹ä¸­ç‚¹", km:quarter, p:p25, cond:(kmTotal>10) },
    { label:"è·¯çº¿ä¸­ç‚¹", km:halfKm,   p:p50 },
    { label:"ååŠç¨‹ä¸­ç‚¹", km:threeQ, p:p75, cond:(kmTotal>10) },
    { label:"æœ€é«˜ç‚¹", km:highKm, p:highest },
    { label:"ç»ˆç‚¹", km:kmTotal, p:end }
  ];

  let points = candidates.filter(c => c.cond === undefined || c.cond);
  points.sort((a,b)=> a.km - b.km);

  const weatherCache = {};
  const coordKey = (lat,lon)=> `${lat.toFixed(4)},${lon.toFixed(4)}`;

  const zones = [];
  const lapse = 6.5;  // æ ‡å‡†é€’å‡ç‡ â„ƒ/km

    // â€¦â€¦ä¸Šé¢ä»£ç ä¿ç•™ä¸åŠ¨â€¦â€¦

  for (let i=0; i<points.length; i++){
    const c   = points[i];
    const lat = c.p.lat;
    const lon = c.p.lon;
    const ele = c.p.ele;

    const key = coordKey(lat,lon);
    let w = weatherCache[key];
    if(!w){
      w = await fetchDailyWeather(lat,lon,dateStr);
      weatherCache[key] = w;
    }

    // â˜…â˜…â˜… æ­£ç¡®çš„å±±åŒºæ°”æ¸©ä¿®æ­£ï¼ˆæ ¸å¿ƒï¼‰
    const modelEle = w.modelElevation;        // æ¨¡å‹ç½‘æ ¼æµ·æ‹”
    const deltaEle = ele - modelEle;          // å®é™…æµ·æ‹”å·®
    const adjTmin  = Math.round(w.tmin - lapse*(deltaEle/1000));
    const adjTmax  = Math.round(w.tmax - lapse*(deltaEle/1000));

    // ç™½å¤©ä½“æ„Ÿæ¸©åº¦
    const midT = Math.round((adjTmin + adjTmax)/2);
    const feel = Math.round(midT - 0.3 * w.wind);

    const frost = adjTmin <= 0 ? " | æ¸…æ™¨å¯èƒ½å‡ºç°éœœå†»" : "";

    const desc =
      `æµ·æ‹”çº¦ ${Math.round(ele)} mï¼Œç™½å¤©ä½“æ„Ÿæ¸©åº¦çº¦ ${feel}â„ƒï¼Œ` +
      `${w.fullText}ï¼Œé£åŠ› ${w.wind} m/sï¼Œé™æ°´æ¦‚ç‡ ${w.pop}%ï½œç´«å¤–çº¿ ${w.uv}${frost}`;

    // â˜…â˜…â˜… æ ‡å‡†åŒ–åçš„å¤©æ°”èŠ‚ç‚¹ï¼ˆæºå¤´å®šä¹‰ï¼‰
    const summaryParts = [];
    // é¡ºåºï¼šå¤©æ°”ï½œå¹³å‡æ°”æ¸©ï½œé£ï½œé™æ°´ï½œUVï½œä½“æ„Ÿï¼ˆä½“æ„Ÿæœ€åï¼‰
    if (w.short)      summaryParts.push(w.short);
    summaryParts.push(`${midT}Â°`);
    summaryParts.push(`${w.wind}m/s`);
    summaryParts.push(`${w.pop}%`);
    summaryParts.push(`UV ${w.uv}`);
    summaryParts.push(`ä½“æ„Ÿ ${feel}Â°`);

    zones.push({
      id: `Z${i+1}`,
      label: c.label,
      km: c.km,
      ele,
      lat,
      lon,

      // ====== 1ï¼‰å®¢æˆ·ç«¯ / ç¼–è¾‘å™¨æ ¸å¿ƒå­—æ®µï¼ˆä»¥åç»Ÿä¸€ç”¨è¿™å‡ ä¸ªï¼‰ ======
      wxShort: w.short,            // "æ™´" / "å¤šäº‘" / "å°é›ª"
      tMin: adjTmin,               // â„ƒï¼Œæ•´å‹
      tMax: adjTmax,               // â„ƒï¼Œæ•´å‹
      midT,                        // ä¸­é—´å€¼ï¼Œç”¨äºä¸€ç›®äº†ç„¶æ¸©åº¦
      windNum: w.wind,             // é£é€Ÿ m/sï¼ˆæ•°å€¼ï¼‰
      popPct: w.pop,               // é™æ°´æ¦‚ç‡ %
      uvIndex: w.uv,               // ç´«å¤–çº¿æŒ‡æ•°
      feelNum: feel,               // ä½“æ„Ÿæ¸©åº¦ â„ƒ

      // ====== 2ï¼‰æ–‡æœ¬è¾…åŠ©å­—æ®µï¼ˆå…¼å®¹æ—§é€»è¾‘ï¼‰ ======
      // æ ‡é¢˜é‡Œç”¨çš„æ¸©åº¦åŒºé—´
      temp: `${adjTmin}â€“${adjTmax}â„ƒ`,
      // çŸ­æ ‡é¢˜ï¼šå¤©æ°” + æ¸©åº¦åŒºé—´ï¼ˆç»™ G1 æŠ¥å‘Šç”¨ï¼‰
      shortName: `${w.short}ï½œ${adjTmin}â€“${adjTmax}â„ƒ`,
      // ç®€çŸ­æè¿°ï¼ˆç»™æ‰‹æœº / ç¼–è¾‘å™¨ç”¨ï¼Œä½“æ„Ÿåœ¨æœ€åï¼‰
      summary: summaryParts.join(" | "),
      // è¯¦ç»†æè¿°ï¼ˆG1 æŠ¥å‘Šç”¨ï¼Œé•¿æ–‡æœ¬ï¼‰
      desc,
      info: `é™æ°´æ¦‚ç‡ ${w.pop}%ï½œç´«å¤–çº¿ ${w.uv}`,
      algo: `ä½¿ç”¨å…³é”®ç‚¹â€œ${c.label}â€çš„åæ ‡è°ƒç”¨ Open-Meteo é¢„æŠ¥ï¼›æŒ‰æ ‡å‡†é€’å‡ç‡ä¿®æ­£æ¸©åº¦ï¼Œå¹¶ä½¿ç”¨ç™½å¤©æ°”æ¸©ä¸é£é€Ÿä¼°ç®—ä½“æ„Ÿæ¸©åº¦ã€‚`,

      // ====== 3ï¼‰ä¿ç•™åŸå§‹å¤©æ°”æ•°æ®ï¼Œæ–¹ä¾¿æœªæ¥æ‰©å±• ======
      raw: {
        apiCode: w.code,
        modelElevation: w.modelElevation,
        originalTmin: w.tmin,
        originalTmax: w.tmax
      }
    });
  }

  return zones;
}


//------------------------------------------------------
// â˜… å¿…é¡»è¡¥å›çš„å·¥å…·å‡½æ•°ï¼ˆç¼ºå®ƒä»¬å°±ä¼šæŠ¥é”™ï¼‰
//------------------------------------------------------
function fmtKm(km){
  if (km === undefined || km === null) return "-";
  return km.toFixed(2);
}

function fmtCoord(pt, label="æŸ¥çœ‹"){
  if (!pt || pt.lat == null || pt.lon == null) return "-";
  const url = `https://www.google.com/maps?q=${pt.lat},${pt.lon}`;
  return `<a href="${url}" target="_blank">${label}</a>`;
}

function fmtEle(ele){
  if (ele === undefined || ele === null) return "-";
  return `${ele.toFixed(0)} m`;
}
// å°† naturalSplit å¾—åˆ°çš„åœ°è²Œæ®µåšäºŒæ¬¡åˆå¹¶ï¼Œè¿‡æ»¤â€œå™ªå£°æ®µâ€
function mergeGeomSegments(segments) {
  const MIN_LEN_KM   = 0.15; // 150m ä»¥ä¸‹ä¸å•ç‹¬æˆæ®µ
  const MIN_ELEV_DIFF = 30;  // æµ·æ‹”å˜åŒ– <30m ä¸”å¾ˆçŸ­æ—¶è§†ä¸ºå™ªå£°

  if (!segments || segments.length === 0) return [];

  const merged = [];

  segments.forEach(seg => {
    // å¤åˆ¶ä¸€ä»½ï¼Œé¿å…æ„å¤–ä¿®æ”¹åŸå¯¹è±¡
    const cur = {
      startKm: seg.startKm,
      endKm:   seg.endKm,
      startPt: seg.startPt,
      endPt:   seg.endPt,
      type:    seg.type
    };

    const lenKm = cur.endKm - cur.startKm;
    const elevDiff = Math.abs(cur.endPt.ele - cur.startPt.ele);

    if (merged.length === 0) {
      merged.push(cur);
      return;
    }

    const last = merged[merged.length - 1];

    // è§„åˆ™ 1ï¼šå¦‚æœè¿™ä¸ªæ®µ <150m ä¸”æµ·æ‹”å˜åŒ– <30mï¼Œåˆ™åˆå¹¶åˆ°å‰ä¸€æ®µ
    if (lenKm < MIN_LEN_KM && elevDiff < MIN_ELEV_DIFF) {
      last.endKm = cur.endKm;
      last.endPt = cur.endPt;
      return;
    }

    // è§„åˆ™ 2ï¼šç±»å‹å®Œå…¨ä¸€æ ·ï¼Œä¹Ÿç›´æ¥åˆå¹¶ï¼Œé¿å…åŒç±»å‹è¿ç»­å°æ®µ
    if (cur.type === last.type) {
      last.endKm = cur.endKm;
      last.endPt = cur.endPt;
      return;
    }

    // å…¶å®ƒæƒ…å†µï¼šä¿ç•™ä¸ºæ–°çš„ä¸€ä¸ªè‡ªç„¶æ®µ
    merged.push(cur);
  });

  return merged;
}

//-----------------------------------------------------
// Step2ï¼šG1 æŠ¥å‘Š
//-----------------------------------------------------
async function buildG1(){
  if(trackPoints.length<2){ alert("è¯·å…ˆè§£æè½¨è¿¹"); return; }

  const dateInput = document.getElementById("dateInput").value;
  const date      = dateInput || "ï¼ˆæœªå¡«å†™ï¼‰";

  const kmTotal=totalDist/1000;
  const start=trackPoints[0];
  const end=trackPoints[trackPoints.length-1];

  const progressContainer=document.getElementById("progressContainer");
  const progressBar=document.getElementById("progressBar");
  const progressText=document.getElementById("progressText");
  progressContainer.style.display="block";
  progressBar.style.width="0%";
  progressText.textContent="å¼€å§‹ç”Ÿæˆ G1 æ®µè½â€¦";

    // 2. åœ°å½¢è‡ªç„¶åˆ†æ®µï¼šTopoSeg v2ï¼ˆå¡åº¦ + åˆå¹¶çŸ­æ®µï¼‰
  const terrainSegments = topoSeg20(trackPoints);

  g1Segments = terrainSegments.map((seg, i) => {
    const sKm = seg.startKm;
    const eKm = seg.endKm;
    const distKm = Math.max(0.001, eKm - sKm);
    const pS = seg.startPt;
    const pE = seg.endPt;
    const deltaEle = pE.ele - pS.ele;
    const slope = classifySlope(deltaEle, distKm);
    const meanEle = (pS.ele + pE.ele) / 2;
    const band = altBandLabel(meanEle);
    const geom = geomorphDesc(meanEle, slope.label);

    return {
      id:        `G${i+1}`,
      startKm:   sKm,
      endKm:     eKm,
      deltaEle:  Math.round(deltaEle),
      slopePct:  slope.pct,

      // è¿™ä¸¤ä¸ªæ˜¯ç»™ 2.1 è¡¨æ ¼ç”¨çš„å­—æ®µ
      slopeClass:  seg.slopeClass,    // â† æ¥è‡ª topoSeg20 é‡Œçš„ slopeClass
      description: seg.description,   // â† topoSeg20 é‡Œæ‹¼å‡ºæ¥çš„ desc

      // ä¸‹é¢æ˜¯ä½ åŸæ¥å°±æœ‰çš„å­—æ®µ
      slopeLabel: seg.type,           // ä¾›åœºæ™¯æ ‡é¢˜ç”¨
      altBand:    band,
      geom:       geom,
      startPt:    pS,
      endPt:      pE
    };
  });


  // æ‰©å±•ä¿¡æ¯ï¼šé€æ®µè°ƒç”¨å¤–éƒ¨æ•°æ®ï¼Œå¹¶æ›´æ–°è¿›åº¦æ¡
  for (let i=0;i<g1Segments.length;i++) {
    const seg = g1Segments[i];
    try {
      seg.ext = await analyzeSegmentExt(seg);
    } catch (e) {
      console.warn("G æ®µæ‰©å±•åˆ†æå¤±è´¥", seg.id, e);
      seg.ext = null;
    }
    const pct = Math.round(((i+1)/g1Segments.length)*100);
    progressBar.style.width=pct+"%";
    progressText.textContent=`G1 åˆ†æ®µæ‰©å±•åˆ†æï¼š${i+1}/${g1Segments.length} ï¼ˆ${pct}%ï¼‰`;
  }

    // 3. æ¤è¢«åˆ†æ®µï¼šæŒ‰ altBand æ–‡æœ¬åˆå¹¶ â€”â€” å†™å›åˆ°å…¨å±€ vegSeg
  vegSeg = [];
  let cur = null;

  g1Segments.forEach((s, idx) => {
    if (!cur) {
      cur = {
        id:      "V1",
        startKm: s.startKm,
        endKm:   s.endKm,
        label:   s.altBand
      };
    } else if (cur.label === s.altBand) {
      // åŒä¸€æ¤è¢«å¸¦ï¼Œç»§ç»­å»¶é•¿
      cur.endKm = s.endKm;
    } else {
      // æ¢æ¤è¢«å¸¦ï¼Œæ”¶å‰ä¸€æ®µï¼Œèµ·ä¸€æ®µæ–°çš„
      vegSeg.push(cur);
      cur = {
        id:      `V${vegSeg.length + 1}`,
        startKm: s.startKm,
        endKm:   s.endKm,
        label:   s.altBand
      };
    }

    // æœ€åä¸€æ®µåˆ«å¿˜äº†æ¨å…¥
    if (idx === g1Segments.length - 1 && cur) {
      vegSeg.push(cur);
    }
  });


  // ç»“æ„å‹å…³é”®ç‚¹ï¼ˆç¤ºä¾‹è®¾æ–½ï¼‰
  let highest=trackPoints[0];
  trackPoints.forEach(p=>{ if(p.ele>highest.ele) highest=p; });
  const highKm=highest.cumDist/1000;
  const midKm =kmTotal/2;
  const facilities=[
    {id:"F1",name:"èµ·ç‚¹ / åœè½¦æˆ–ç™»è®°ç‚¹ï¼ˆéœ€ä¸å®é™…åœ°å›¾å¯¹ç…§ç¡®è®¤ï¼‰",km:0},
    {id:"F2",name:"è·¯çº¿ä¸­ç‚¹é™„è¿‘ä¼‘æ¯/è§‚å¯ŸåŒºï¼ˆè‡ªåŠ¨æ¨ç®—ï¼‰",km:midKm},
    {id:"F3",name:"çº¿è·¯æœ€é«˜ç‚¹é™„è¿‘è§‚æ™¯/é€šè¿‡ç‚¹ï¼ˆè‡ªåŠ¨æ¨ç®—ï¼‰",km:highKm},
    {id:"F4",name:"ç»ˆç‚¹ / ä¸»è¦è§‚æ™¯æˆ–å›ç¨‹èŠ‚ç‚¹ï¼ˆéœ€ä¸å®é™…åœ°å›¾å¯¹ç…§ç¡®è®¤ï¼‰",km:kmTotal}
  ];
// ========= 0bï¼šå½“æ—¥å¤©æ°”æ¦‚è¦ï¼ˆæ–°ç‰ˆï¼Œå®Œå…¨å¯è¦†ç›–ï¼‰ =========
let weatherBlock = "";
let dailyW = null;

if (dateInput) {
  try {
    // é€‰æ‹©æ•´æ¡è·¯çº¿â€œä¸­ç‚¹â€ä½œä¸ºä»£è¡¨å¤©æ°”ç‚¹
    const mid = interpKm(kmTotal / 2);
    const w   = await fetchDailyWeather(mid.lat, mid.lon, dateInput);
    dailyW    = w;

    // â˜… æ­£ç¡®å±±åŒºæ¸©åº¦ä¿®æ­£ï¼šä½¿ç”¨æ¨¡å‹æµ·æ‹”ä½œä¸ºåŸºå‡†
    const lapse    = 6.5;                      // â„ƒ / km æ ‡å‡†å‚ç›´é€’å‡ç‡
    const modelEle = w.modelElevation ?? 0;     // Open-Meteo æä¾›çš„ç½‘æ ¼åœ°è¡¨æµ·æ‹”
    const deltaEle = mid.ele - modelEle;        // å®é™…æµ·æ‹”å·®

    const adjTmin = Math.round(w.tmin - lapse * (deltaEle / 1000));
    const adjTmax = Math.round(w.tmax - lapse * (deltaEle / 1000));

    // ç™½å¤©æ°”æ¸©ä¸­ä½æ•° â†’ ä½“æ„Ÿæ¸©åº¦
    const midT = Math.round((adjTmin + adjTmax) / 2);
    const windUsed = Math.min(Math.max(w.wind, 0), 15);
    const feel = Math.round(midT - 0.3 * windUsed);

    // â˜… æ–°ç‰ˆ 0b æ˜¾ç¤ºæ ¼å¼ï¼šå¤©æ°”ä¸»é¢˜ï¼‹åŒºé—´æ¸©åº¦
    //   å»é™¤â€œåŸºç¡€å¤©æ°”â€ã€å»é™¤æ‰€æœ‰æ‹¬å·è¯´æ˜
    weatherBlock = `
<h3>0b. å½“æ—¥å¤©æ°”ï¼ˆG1 å¿…é€‰é¡¹ï½œæ•´æ¡è·¯çº¿æ¦‚è¦ï¼‰</h3>
<table>
  <tr><th>é¡¹ç›®</th><th>æ•°å€¼</th></tr>
  <tr><td>å¤©æ°”</td><td>${w.short}ï½œ${adjTmin}â€“${adjTmax}â„ƒ</td></tr>
  <tr><td>é™æ°´æ¦‚ç‡</td><td>${w.pop}%</td></tr>
  <tr><td>ç´«å¤–çº¿æŒ‡æ•°</td><td>${w.uv}</td></tr>
  <tr><td>é£é€Ÿ</td><td>${w.wind} m/s</td></tr>
  <tr><td>ç™½å¤©ä½“æ„Ÿæ¸©åº¦</td><td>${feel}â„ƒ</td></tr>
</table>

<div class="note">
æ•°æ®æ¥æºï¼šOpen-Meteo å…è´¹å¤©æ°” APIï¼ˆé€æ—¥é¢„æŠ¥ + å½“å‰é£é€Ÿï¼‰ã€‚<br>
æ¸©åº¦ä¿®æ­£ï¼šæ ¹æ® Open-Meteo æ¨¡å‹ç½‘æ ¼æµ·æ‹”ï¼ŒæŒ‰æ ‡å‡†å¤§æ°”é€’å‡ç‡ 6.5â„ƒ/km ä¿®æ­£è‡³è¯¥ä¸­ç‚¹å®é™…æµ·æ‹”ã€‚<br>
ä½“æ„Ÿæ¸©åº¦ï¼šåŸºäºç™½å¤©æ°”æ¸©ä¸é£é€Ÿçš„ç®€åŒ–é£å¯’ä¼°ç®—ï¼Œç”¨äºå¾’æ­¥ä½“æ„Ÿé¢„åˆ¤ã€‚
</div>
`;

  } catch (e) {
    console.warn(e);
    weatherBlock = `
<h3>0b. å½“æ—¥å¤©æ°”ï¼ˆG1 å¿…é€‰é¡¹ï½œæ•´æ¡è·¯çº¿æ¦‚è¦ï¼‰</h3>
<p>å°è¯•ä» Open-Meteo è·å– ${dateInput} çš„å¤©æ°”å¤±è´¥ï¼Œå…³é”®ç‚¹å¤©æ°”æ— æ³•ç”Ÿæˆã€‚</p>`;
  }

} else {
  weatherBlock = `
<h3>0b. å½“æ—¥å¤©æ°”ï¼ˆG1 å¿…é€‰é¡¹ï½œæ•´æ¡è·¯çº¿æ¦‚è¦ï¼‰</h3>
<p>æœªå¡«å†™å…·ä½“å‡ºå‘æ—¥æœŸï¼Œæ— æ³•ç”Ÿæˆå¤©æ°”æ•°æ®ã€‚å¡«å†™æ—¥æœŸåé‡æ–°ç”Ÿæˆ G1ã€‚</p>`;
}

  // å…³é”®ç‚¹å¤©æ°”
  if(dateInput){
    try{
      weatherZones = await buildWeatherKeyPoints(dateInput);
    }catch(e){
      console.warn(e);
      weatherZones = [];
    }
  }else{
    weatherZones = [];
  }

  // ---------- HTML è¾“å‡º ----------
  let html=`
<h3>0. æ—¥æœŸä¸å­£èŠ‚åˆ¤å®š</h3>
<p>å‡ºå‘æ—¥æœŸï¼š${date}</p>
${weatherBlock}

<h3>1. è½¨è¿¹åŸºç¡€ä¿¡æ¯</h3>
<table>
<tr><th>é¡¹ç›®</th><th>æ•°å€¼</th></tr>
<tr><td>è½¨è¿¹ç‚¹æ•°</td><td>${trackPoints.length}</td></tr>
<tr><td>æ€»è·ç¦»</td><td>${kmTotal.toFixed(2)} km</td></tr>
<tr><td>ç´¯è®¡ä¸Šå‡</td><td>${Math.round(ascent)} m</td></tr>
<tr><td>ç´¯è®¡ä¸‹é™</td><td>${Math.round(descent)} m</td></tr>
<tr><td>æœ€ä½æµ·æ‹”</td><td>${Math.round(minEle)} m</td></tr>
<tr><td>æœ€é«˜æµ·æ‹”</td><td>${Math.round(maxEle)} m</td></tr>
<tr><td>èµ·ç‚¹åæ ‡</td><td>${fmtCoord(start)} ï½œ <a href="${mapUrl(start)}" target="_blank">åœ°å›¾</a></td></tr>
<tr><td>ç»ˆç‚¹åæ ‡</td><td>${fmtCoord(end)} ï½œ <a href="${mapUrl(end)}" target="_blank">åœ°å›¾</a></td></tr>
</table>
`;

  // 2.1 åœ°å½¢åˆ†æ®µ
  html+=`
<h3>2.1 åœ°å½¢è‡ªç„¶åˆ†æ®µï¼ˆå¡åº¦ + æµ·æ‹”åŒºé—´ï¼‰</h3>
<table>
<tr>
  <th>ç¼–å·</th>
  <th>é‡Œç¨‹åŒºé—´</th>
  <th>æµ·æ‹”åŒºé—´</th>
  <th>ç®€ç§°</th>
  <th>æè¿°</th>
  <th>èµ·ç‚¹</th>
  <th>ç»ˆç‚¹</th>
  <th>ç®—æ³• / æ¥æº</th>
</tr>`;

  g1Segments.forEach(s=>{
const startEle = Math.round(s.startPt.ele);
const endEle = Math.round(s.endPt.ele);
const eleRangeText = `${startEle}â€“${endEle} m`;

// ä½¿ç”¨ full typeï¼ˆå« å¡ / è·¯ åç¼€ï¼‰
// ä½¿ç”¨ full typeï¼ˆä¾‹å¦‚ï¼šç¼“ä¸Šå¡ / å¹³ç¼“è·¯ï¼‰
const shortLabel = s.type ?? s.slopeClass ?? "æœªçŸ¥";
const descText = s.description ?? "";



    html+=`
<tr>
  <td>${s.id}</td>
  <td>${s.startKm.toFixed(2)}â€“${s.endKm.toFixed(2)} km</td>
  <td>${eleRangeText}</td>
  <td>${shortLabel}</td>
  <td>${descText}</td>
  <td>${fmtCoord(s.startPt)}<br><a href="${mapUrl(s.startPt)}" target="_blank">åœ°å›¾</a></td>
  <td>${fmtCoord(s.endPt)}<br><a href="${mapUrl(s.endPt)}" target="_blank">åœ°å›¾</a></td>
  <td>
    æœ¬æ®µåœ°å½¢åŸºäºå›½é™…å¸¸ç”¨å¾’æ­¥/åœ°è²Œå¡åº¦æ ‡å‡†ï¼š
Â· å¹³ç¼“ï¼šå¡åº¦ |5%| ä»¥ä¸‹ï¼ˆäººä½“éš¾ä»¥æ„ŸçŸ¥ï¼‰
Â· ç¼“ä¸Š / ç¼“ä¸‹ï¼š5%ï½10%
Â· ä¸­ä¸Š / ä¸­ä¸‹ï¼š10%ï½20%
Â· é™¡ä¸Š / é™¡ä¸‹ï¼š20%ï½35%
Â· æé™¡ä¸Š / æé™¡ä¸‹ï¼š>35%
è‡ªç„¶åˆ†æ®µä½äº 30 ç±³çš„çŸ­æ®µè‡ªåŠ¨åˆå¹¶
æ•°æ®æ¥æºï¼šè½¨è¿¹ç´¯ç§¯è·ç¦» + æµ·æ‹”å˜åŒ–ï¼ˆGPX/KML åŸå§‹æ•°æ®ï¼‰
  </td>
</tr>`;
  });

  html+=`</table>`;

   // ================================
  // 2.2 åœ°è²Œåˆ†æ®µï¼ˆç‹¬ç«‹è‡ªç„¶åˆ†æ®µï¼‰
  // ================================
  html += `<h3>2.2 åœ°è²Œåˆ†æ®µï¼ˆæŒ‰å¡åº¦ + æµ·æ‹”å¸¦çš„è‡ªç„¶åˆ†æ®µï¼‰</h3>`;
  html += `<p>è¯´æ˜ï¼šæœ¬è¡¨åŸºäº<strong>åŸå§‹è½¨è¿¹é€ç‚¹</strong>è®¡ç®—å¡åº¦ä¸æµ·æ‹”ï¼Œ
    ä½¿ç”¨åœ°è²Œè§„åˆ™ <code>getLandformType</code> å¯¹æ¯ä¸€ç‚¹è¿›è¡Œåˆ†ç±»ï¼Œ
    ç„¶åå°†<strong>åœ°è²Œç±»å‹ç›¸åŒä¸”è¿ç»­</strong>çš„åŒºé—´è‡ªåŠ¨åˆå¹¶ä¸ºè‡ªç„¶åˆ†æ®µã€‚
    å› æ­¤æœ¬è¡¨çš„æ®µæ•°ä¸å†è·Ÿ 2.1 çš„åœ°å½¢åˆ†æ®µä¸€ä¸€å¯¹åº”ã€‚</p>`;

  html += `<table><thead>
    <tr>
      <th>ç¼–å·</th>
      <th>é‡Œç¨‹åŒºé—´</th>
      <th>æµ·æ‹”åŒºé—´</th>
      <th>ç®€ç§°</th>
      <th>æè¿°</th>
      <th>èµ·ç‚¹</th>
      <th>ç»ˆç‚¹</th>
      <th>ç®—æ³• / æ¥æº</th>
    </tr>
  </thead><tbody>`;

  // åˆ©ç”¨ naturalSplit + getLandformType åšç‹¬ç«‹åœ°è²Œåˆ†æ®µ
const rawGeomSegments = naturalSplit(trackPoints, (pt, idx) => {
  if (idx === 0) return getLandformType(null, pt);
  return getLandformType(trackPoints[idx - 1], pt);
});

// â˜… æ–°å¢ï¼šå¯¹ç»“æœåšä¸€æ¬¡â€œç¨³å®šåˆå¹¶â€
const geomSegments = mergeGeomSegments(rawGeomSegments);

geomSegments.forEach((seg, idx) => {
  // seg.type å½¢å¦‚ â€œæ²³è°· / ä¸˜é™µåœ°å¸¦ï¼šå†œç”°ã€ç‰§åœºä¸ºä¸»â€
  let shortLabel = seg.type;
  let desc = "";
  const colonIdx = seg.type.indexOf("ï¼š");
  if (colonIdx !== -1) {
    shortLabel = seg.type.slice(0, colonIdx);
    desc       = seg.type.slice(colonIdx + 1);
  }

  const eleMin = Math.min(seg.startPt.ele, seg.endPt.ele);
  const eleMax = Math.max(seg.startPt.ele, seg.endPt.ele);

  html += `<tr>
    <td>G${idx+1}</td>
    <td>${fmtKm(seg.startKm)}â€“${fmtKm(seg.endKm)} km</td>
    <td>${eleMin.toFixed(0)}â€“${eleMax.toFixed(0)} m</td>
    <td>${shortLabel}</td>
    <td>${desc}</td>
    <td>${fmtCoord(seg.startPt, "åœ°å›¾")}</td>
    <td>${fmtCoord(seg.endPt, "åœ°å›¾")}</td>
    <td>ä¾æ®ï¼šé€ç‚¹æµ·æ‹” + å¡åº¦çš„åœ°è²Œç±»å‹åˆ¤æ–­ï¼›æ•°æ®æ¥æºï¼šè½¨è¿¹ç‚¹æµ·æ‹”ä¸å¡åº¦ç»Ÿè®¡ã€‚</td>
  </tr>`;
});



  // 2.3 æ¤è¢«åˆ†æ®µ
  html+=`
<h3>2.3 æ¤è¢«åˆ†æ®µï¼ˆæŒ‰æµ·æ‹” + åœ°è²Œåˆå¹¶ï¼‰</h3>
<table>
<tr>
  <th>ç¼–å·</th>
  <th>é‡Œç¨‹åŒºé—´</th>
  <th>æµ·æ‹”åŒºé—´</th>
  <th>ç®€ç§°</th>
  <th>æè¿°</th>
  <th>èµ·ç‚¹</th>
  <th>ç»ˆç‚¹</th>
  <th>ç®—æ³• / æ¥æº</th>
</tr>`;

  vegSeg.forEach(v=>{
    const pS = interpKm(v.startKm);
    const pE = interpKm(v.endKm);
    const startEle = Math.round(pS.ele);
    const endEle = Math.round(pE.ele);
    const eleRangeText = `${startEle}â€“${endEle} m`;
    const shortLabel = v.label;
    const descText = `è¯¥åŒºé—´æ¤è¢«ä¸ç¯å¢ƒé£æ ¼ä»¥ ${v.label} ä¸ºä¸»`;

    html+=`
<tr>
  <td>${v.id}</td>
  <td>${v.startKm.toFixed(2)}â€“${v.endKm.toFixed(2)} km</td>
  <td>${eleRangeText}</td>
  <td>${shortLabel}</td>
  <td>${descText}</td>
  <td>${fmtCoord(pS)}<br><a href="${mapUrl(pS)}" target="_blank">åœ°å›¾</a></td>
  <td>${fmtCoord(pE)}<br><a href="${mapUrl(pE)}" target="_blank">åœ°å›¾</a></td>
  <td>
    ä¾æ®ï¼šå°† G1 å„æ®µçš„æµ·æ‹”å¸¦æè¿°æŒ‰ç›¸é‚»ç›¸åŒæ–‡æœ¬è‡ªåŠ¨åˆå¹¶ã€‚<br>
    æ•°æ®æ¥æºï¼šè½¨è¿¹ç‚¹æµ·æ‹”ï¼ˆGPX/KMLï¼‰ â†’ æµ·æ‹”å¸¦æ¨¡å‹ altBandLabel()ã€‚<br>
    é€‚ç”¨ï¼šåˆ¤æ–­ä¸€è·¯ä¸Šæ¤è¢«å’Œç¯å¢ƒé£æ ¼çš„å˜åŒ–èŠ‚å¥ã€‚
  </td>
</tr>`;
  });

  html+=`</table>`;

  // 3. è·¯é¢ä¸é€šè¡Œæ¡ä»¶
  html+=`
<h3>3. è·¯é¢ä¸é€šè¡Œæ¡ä»¶</h3>
<table>
<tr>
  <th>ç¼–å·</th>
  <th>é‡Œç¨‹åŒºé—´</th>
  <th>æµ·æ‹”åŒºé—´</th>
  <th>ç®€ç§°</th>
  <th>æè¿°</th>
  <th>èµ·ç‚¹</th>
  <th>ç»ˆç‚¹</th>
  <th>ç®—æ³• / æ¥æº</th>
</tr>`;

  g1Segments.forEach(s=>{
    const ext = s.ext || {};
    const startEle = Math.round(s.startPt.ele);
    const endEle = Math.round(s.endPt.ele);
    const eleRangeText = `${startEle}â€“${endEle} m`;
    const shortLabel = ext.surface || "è‡ªç„¶å±±è·¯ / è·¯é¢ä¿¡æ¯ä¸è¶³";
    const descText = `å±é™©æç¤ºï¼š${ext.hazards || "æš‚æ— æ˜æ˜¾å±é™©ç‰¹å¾"}`;

    html+=`
<tr>
  <td>${s.id}</td>
  <td>${s.startKm.toFixed(2)}â€“${s.endKm.toFixed(2)} km</td>
  <td>${eleRangeText}</td>
  <td>${shortLabel}</td>
  <td>${descText}</td>
  <td>${fmtCoord(s.startPt)}<br><a href="${mapUrl(s.startPt)}" target="_blank">åœ°å›¾</a></td>
  <td>${fmtCoord(s.endPt)}<br><a href="${mapUrl(s.endPt)}" target="_blank">åœ°å›¾</a></td>
  <td>
    è·¯é¢ä¿¡æ¯ä¼˜å…ˆæ¥è‡ª OSM çš„ surface / highway æ ‡ç­¾ï¼ˆOverpass API 200m åŠå¾„æ£€ç´¢ï¼‰ã€‚<br>
    è‹¥æ— æ˜ç¡®æ ‡ç­¾ï¼Œåˆ™æŒ‰â€œè‡ªç„¶å±±è·¯ / æ··åˆè·¯é¢â€å¤„ç†ï¼Œä»…åšä½“éªŒæç¤ºã€‚<br>
    å±é™©æç¤ºä¾æ®ï¼šå¡åº¦é˜ˆå€¼ï¼ˆ|å¡åº¦|â‰¥25%ï¼‰ã€OSM trail_visibility=bad ç­‰ã€‚<br>
    æ•°æ®æ¥æºï¼šOpenStreetMap + è½¨è¿¹å¡åº¦è®¡ç®—ã€‚
  </td>
</tr>`;
  });

  html+=`</table>`;

  // 4. è®¾æ–½åˆ†å¸ƒ
  html+=`
<h3>4. è®¾æ–½åˆ†å¸ƒï¼ˆäººé€ æœåŠ¡ä¸å®‰å…¨è®¾æ–½ï¼‰</h3>
<table>
<tr>
  <th>ç¼–å·</th>
  <th>é‡Œç¨‹åŒºé—´</th>
  <th>æµ·æ‹”åŒºé—´</th>
  <th>ç®€ç§°</th>
  <th>æè¿°</th>
  <th>èµ·ç‚¹</th>
  <th>ç»ˆç‚¹</th>
  <th>ç®—æ³• / æ¥æº</th>
</tr>`;

  g1Segments.forEach(s=>{
    const ext = s.ext || {};
    const fac = ext.facilities || [];
    const facText = fac.length ? fac.slice(0,3).join("ã€") + (fac.length>3?" ç­‰":"") : "é™„è¿‘æœªæ£€å‡ºæ˜ç¡®è®¾æ–½ï¼ˆæˆ– OSM æœªæ”¶å½•ï¼‰";
    const startEle = Math.round(s.startPt.ele);
    const endEle = Math.round(s.endPt.ele);
    const eleRangeText = `${startEle}â€“${endEle} m`;
    const shortLabel = fac.length ? fac[0] : "è®¾æ–½ä¿¡æ¯æœ‰é™";
    const descText = facText;

    html+=`
<tr>
  <td>${s.id}</td>
  <td>${s.startKm.toFixed(2)}â€“${s.endKm.toFixed(2)} km</td>
  <td>${eleRangeText}</td>
  <td>${shortLabel}</td>
  <td>${descText}</td>
  <td>${fmtCoord(s.startPt)}<br><a href="${mapUrl(s.startPt)}" target="_blank">åœ°å›¾</a></td>
  <td>${fmtCoord(s.endPt)}<br><a href="${mapUrl(s.endPt)}" target="_blank">åœ°å›¾</a></td>
  <td>
    åœ¨æ¯ä¸ª G æ®µä¸­ç‚¹é™„è¿‘ 200m èŒƒå›´å†…ï¼Œé€šè¿‡ OSM Overpass æ£€ç´¢ tourism/amenity èŠ‚ç‚¹ã€‚<br>
    ä»…å±•ç¤ºå‰ 3 ä¸ªåç§°ä½œä¸ºæ‘˜è¦ï¼Œå…·ä½“ä½ç½®éœ€åœ¨åœ°å›¾ä¸ŠäºŒæ¬¡ç¡®è®¤ã€‚<br>
    æ•°æ®æ¥æºï¼šOpenStreetMap POIï¼›å®é™…ç°åœºè®¾æ–½å¯èƒ½æ™šäºæˆ–æ—©äº OSM æ•°æ®æ›´æ–°ã€‚
  </td>
</tr>`;
  });

  html+=`</table>`;

  // 5. æ™¯è§‚ä¸æ–‡åŒ–è¦ç´ 
  html+=`
<h3>5. æ™¯è§‚ä¸æ–‡åŒ–è¦ç´ </h3>
<table>
<tr>
  <th>ç¼–å·</th>
  <th>é‡Œç¨‹åŒºé—´</th>
  <th>æµ·æ‹”åŒºé—´</th>
  <th>ç®€ç§°</th>
  <th>æè¿°</th>
  <th>èµ·ç‚¹</th>
  <th>ç»ˆç‚¹</th>
  <th>ç®—æ³• / æ¥æº</th>
</tr>`;

  g1Segments.forEach(s=>{
    const ext = s.ext || {};
    const culture = ext.culture || "é™„è¿‘æ— æ˜æ˜¾æ–‡åŒ–/åœ°åæ¡ç›®";
    const startEle = Math.round(s.startPt.ele);
    const endEle = Math.round(s.endPt.ele);
    const eleRangeText = `${startEle}â€“${endEle} m`;
    const shortLabel = culture.split("ã€")[0];
    const descText = culture;

    html+=`
<tr>
  <td>${s.id}</td>
  <td>${s.startKm.toFixed(2)}â€“${s.endKm.toFixed(2)} km</td>
  <td>${eleRangeText}</td>
  <td>${shortLabel}</td>
  <td>${descText}</td>
  <td>${fmtCoord(s.startPt)}<br><a href="${mapUrl(s.startPt)}" target="_blank">åœ°å›¾</a></td>
  <td>${fmtCoord(s.endPt)}<br><a href="${mapUrl(s.endPt)}" target="_blank">åœ°å›¾</a></td>
  <td>
    é€šè¿‡ Wikidata SPARQL ä»¥ G æ®µä¸­ç‚¹ä¸ºåœ†å¿ƒï¼Œ1km åŠå¾„å†…æ£€ç´¢æœ€è¿‘çš„åœ°ç†å®ä½“åç§°ï¼ˆå±±å³°ã€æ¹–æ³Šã€æ™¯åŒºã€å®šå±…ç‚¹ç­‰ï¼‰ã€‚<br>
    è¿™äº›åç§°ç”¨äºæç¤ºå¯èƒ½çš„æ™¯è§‚/æ–‡åŒ–ä¿¡æ¯ï¼Œå…·ä½“æ•…äº‹ä¸è§£è¯»ä»éœ€é¢†é˜Ÿç»“åˆå†å²èµ„æ–™ä¸ç°åœºä½“éªŒè¡¥å……ã€‚<br>
    æ•°æ®æ¥æºï¼šWikidata + åæ ‡åå‘åœ°ç†æŸ¥è¯¢ï¼›éƒ¨åˆ†åè¿œåœ°åŒºå¯èƒ½æ— è¿”å›æ•°æ®ã€‚
  </td>
</tr>`;
  });

  html+=`</table>`;

  // 7. å½“å¤©å¤©æ°”å…³é”®ç‚¹
  html+=`
<h3>7. å½“å¤©å¤©æ°”å…³é”®ç‚¹ï¼ˆZ1â€“Z${weatherZones.length || 0}ï¼‰</h3>`;

  if (weatherZones.length === 0) {
    html += `<p>ç”±äºæœªèƒ½è·å–å½“æ—¥å¤©æ°”æˆ–æœªå¡«å†™å‡ºå‘æ—¥æœŸï¼Œæœ¬èŠ‚æš‚æ— æ³•ç”Ÿæˆå®é™…å…³é”®ç‚¹å¤©æ°”ï¼Œä»…ä¿ç•™ç»“æ„è¯´æ˜ã€‚</p>`;
  } else {
    html += `
<table>
<tr>
  <th>ç¼–å·</th>
  <th>é‡Œç¨‹åŒºé—´</th>
  <th>æµ·æ‹”åŒºé—´</th>
  <th>æ¸©åº¦ï¼ˆç®€ç§°ï¼‰</th>
  <th>æè¿°ï¼ˆä½“æ„Ÿæ¸©åº¦ + å…¶ä»–æ•°æ®ï¼‰</th>
  <th>èµ·ç‚¹</th>
  <th>ç»ˆç‚¹</th>
  <th>ç®—æ³• / æ¥æº</th>
</tr>`;

    weatherZones.forEach(z => {
      const kmText = `${z.km.toFixed(2)}â€“${z.km.toFixed(2)} km`;
      const eleText = `${Math.round(z.ele)}â€“${Math.round(z.ele)} m`;
      const coordObj = { lat: z.lat, lon: z.lon };
      const coordText = fmtCoord(coordObj);
      const mapLink = mapUrl(coordObj);

      const tempShort = z.temp;
      const feelAndOthers = `ä½“æ„Ÿ ${z.feel}ï½œé£ ${z.wind}ï½œ${z.info}`;

      html += `
<tr>
  <td>${z.id}</td>
  <td>${kmText}</td>
  <td>${eleText}</td>
  <td>${tempShort}</td>
  <td>${feelAndOthers}</td>
  <td>${coordText}<br><a href="${mapLink}" target="_blank">åœ°å›¾</a></td>
  <td>${coordText}<br><a href="${mapLink}" target="_blank">åœ°å›¾</a></td>
  <td>
    ${z.algo}<br>
    æ•°æ®æ¥æºï¼šOpen-Meteo å¤©æ°” APIï¼ˆå½“æ—¥é€æ—¥é¢„æŠ¥ + å½“å‰é£é€Ÿï¼‰ï¼‹ è½¨è¿¹æµ·æ‹” / è·ç¦»ï¼›<br>
    æ¸©åº¦æŒ‰æ ‡å‡†å¤§æ°”é€’å‡ç‡ï¼ˆçº¦ 6.5â„ƒ/kmï¼‰ä¿®æ­£è‡³è¯¥ç‚¹æµ·æ‹”ï¼Œä»…ç”¨äºå¾’æ­¥ä½“æ„Ÿé¢„ä¼°ã€‚
  </td>
</tr>`;
    });

    html += `</table>`;
  }

  html+=`
<div class="note">
è¯´æ˜ï¼šå¤©æ°”å…³é”®ç‚¹æŒ‰â€œèµ·ç‚¹ / å‰åŠç¨‹ä¸­ç‚¹ / ä¸­ç‚¹ / ååŠç¨‹ä¸­ç‚¹ / æœ€é«˜ç‚¹ / ç»ˆç‚¹â€è§„åˆ™è‡ªåŠ¨é€‰ç‚¹ï¼›<br>
æ¯ä¸ªç‚¹ç‹¬ç«‹è°ƒç”¨å¤©æ°”æ¥å£å¹¶æŒ‰è¯¥ç‚¹æµ·æ‹”ä¿®æ­£ä½“æ„Ÿæ¸©åº¦ï¼Œç”¨äºç»™é¢†é˜Ÿåšè£…å¤‡ä¸èŠ‚å¥åˆ¤æ–­å‚è€ƒã€‚
</div>
`;

  // ---------- æŠŠç»“æœå†™å…¥ unified7 ----------
  unified7 = {
    weather: weatherZones,

    geomorph: naturalSplit(trackPoints, (pt,idx)=>{
      return idx>0 ? getTerrainType(trackPoints[idx-1], pt) : "start";
    }).map((s,i)=>({
      id:"T"+(i+1),
      startKm:s.startKm,
      endKm:s.endKm,
      label:s.type,
      desc:s.type,
      startPt:s.startPt,
      endPt:s.endPt,
      source:"è‡ªç„¶åˆ†æ®µï¼šå¡åº¦é˜ˆå€¼"
    })),

    geomorphology: naturalSplit(trackPoints, (pt,idx)=>{
      return idx>0 ? getLandformType(trackPoints[idx-1], pt) : "start";
    }).map((s,i)=>({
      id:"GEO"+(i+1),
      startKm:s.startKm,
      endKm:s.endKm,
      label:s.type,
      desc:s.type,
      startPt:s.startPt,
      endPt:s.endPt,
      source:"è‡ªç„¶åˆ†æ®µï¼šåœ°è²Œæ¨¡å‹"
    })),

    vegetation: naturalSplit(trackPoints, getVegetationType).map((s,i)=>({
      id:"V"+(i+1),
      startKm:s.startKm,
      endKm:s.endKm,
      label:s.type,
      desc:s.type,
      startPt:s.startPt,
      endPt:s.endPt,
      source:"è‡ªç„¶åˆ†æ®µï¼šæµ·æ‹”å¸¦æ¨¡å‹"
    })),

    surface: naturalSplit(trackPoints, getSurfaceType).map((s,i)=>({
      id:"SFC"+(i+1),
      startKm:s.startKm,
      endKm:s.endKm,
      label:s.type,
      desc:s.type,
      startPt:s.startPt,
      endPt:s.endPt,
      source:"è‡ªç„¶åˆ†æ®µï¼šOSM surface"
    })),

    facility: splitFacilities(trackPoints),
    culture:  splitCultural(trackPoints),
    summary:[]
  };

  document.getElementById("g1").innerHTML=html;
  progressText.textContent+="ï½œå®Œæˆ";
  updateG1Export();

}


//-----------------------------------------------------
// â­ æ­£ç¡®çš„ G1 JSON è¾“å‡ºï¼šå¿…é¡»åœ¨ buildG1() æ‰§è¡Œå®Œä¹‹åç”Ÿæˆ
//-----------------------------------------------------
function updateG1Export() {

    window.G1_EXPORT = {
        // 1ï¼‰æ•´æ¡çº¿è·¯çš„å‰–é¢ï¼ˆä¿ç•™åŸæ¥çš„ profileï¼‰
        profile: trackPoints.map(p => ({
    km: +(p.cumDist / 1000).toFixed(3),
    ele: p.ele,
    lat: p.lat,
    lon: p.lon
})),

        // 2ï¼‰åœ°å½¢è‡ªç„¶åˆ†æ®µ S æ®µ â€”â€” åŒ…å«ä½ è¦æ±‚çš„æ‰€æœ‰å­—æ®µ
        segments: g1Segments.map((s, i) => ({
            // æ®µå·ï¼šç»Ÿä¸€ç”¨ S1ã€S2â€¦ï¼ˆä¹Ÿå¯ä»¥æ”¹æˆ s.idï¼Œçœ‹ä½ å‰ç«¯ä¹ æƒ¯ï¼‰
            id: `S${i + 1}`,

            // é‡Œç¨‹åŒºé—´
            startKm: +s.startKm.toFixed(3),
            endKm:   +s.endKm.toFixed(3),

            // æµ·æ‹”åŒºé—´
            startEle: Math.round(s.startPt.ele),
            endEle:   Math.round(s.endPt.ele),

            // åœ°å½¢ç®€ç§° & æè¿°ï¼ˆæ¥è‡ª TopoSeg20ï¼‰
            type: s.slopeClass,       // ä¾‹å¦‚ â€œç¼“ä¸Š / ä¸­ä¸‹ / æé™¡ä¸‹â€¦â€
            desc: s.description,      // â€œæŒç»­ xxx mï½œé«˜å·® Â±xx mï½œæ–œç‡ x.x%ï½œå¡åº¦ x.xÂ°â€

            // æ–¹ä¾¿åç»­ä½¿ç”¨çš„æ•°å€¼ï¼ˆå¯ä»¥ä¸ç»™å‰ç«¯ç”¨ï¼Œä½†ä¿ç•™æ²¡åå¤„ï¼‰
            deltaEle: s.deltaEle,
            slopePct: s.slopePct,

            // èµ·ç‚¹ / ç»ˆç‚¹ï¼ˆå¸¦ç»çº¬åº¦ï¼Œå¯ç›´æ¥æ‹¿å»åšåœ°å›¾é“¾æ¥ï¼‰
            startPt: {
                lat: s.startPt.lat,
                lon: s.startPt.lon,
                ele: s.startPt.ele
            },
            endPt: {
                lat: s.endPt.lat,
                lon: s.endPt.lon,
                ele: s.endPt.ele
            }
        })),

                  // 3ï¼‰å¤©æ°”å…³é”®ç‚¹ï¼ˆç»Ÿä¸€æºå¤´å­—æ®µï¼‰
    weatherNodes: (weatherZones || []).map((z, i) => ({
        id:   z.id || `W${i + 1}`,
        km:   +z.km.toFixed(3),
        lat:  z.lat,
        lon:  z.lon,

        // ---- æ ‡å‡†å­—æ®µï¼šå®¢æˆ·ç«¯ & ç¼–è¾‘å™¨éƒ½åªè®¤è¿™ä¸€å¥— ----
        weather: z.wxShort || "",                          // å¤©æ°”ä¸»é¢˜ï¼šæ™´ / å¤šäº‘ / å°é›ªâ€¦
        tMin:    typeof z.tMin    === "number" ? z.tMin    : null,
        tMax:    typeof z.tMax    === "number" ? z.tMax    : null,
        midT:    typeof z.midT    === "number" ? z.midT    : null,
        wind:    typeof z.windNum === "number" ? z.windNum : null,   // m/s
        pop:     typeof z.popPct  === "number" ? z.popPct  : null,   // %
        uv:      typeof z.uvIndex === "number" ? z.uvIndex : null,
        feel:    typeof z.feelNum === "number" ? z.feelNum : null,   // â„ƒï¼ˆä½“æ„Ÿï¼Œæœ€åï¼‰

        // ---- æ–‡æœ¬å­—æ®µï¼ˆç»™æŠ¥è¡¨ / ç¼–è¾‘å™¨å±•ç¤ºç”¨ï¼‰ ----
        temp:    z.temp || "",            // åŒºé—´æ–‡æœ¬ï¼š-2â€“1â„ƒ ä¹‹ç±»
        shortName: z.shortName || "",     // â€œæ™´ï½œ-2â€“1â„ƒâ€
        summary:  z.summary  || "",       // â€œå¤šäº‘ | 15Â° | 25m/s | 60% | UV 3.2 | ä½“æ„Ÿ 9Â°â€
        desc:     z.desc     || "",       // è¯¦ç»†é•¿æ–‡

        // ---- åŸå§‹æ•°æ®ä¿åº•ï¼ˆä¾¿äºæœªæ¥æ‰©å±•é€»è¾‘ï¼‰ ----
        raw: z.raw || null
    })),



        // 4ï¼‰æ•´æ¡çº¿çš„ metaï¼ˆä¿ç•™ï¼‰
        meta: {
            totalKm:   +(trackPoints.at(-1).cumDist / 1000).toFixed(3),
            startPt:   trackPoints[0],          // æ•´æ¡çº¿çš„èµ·ç‚¹
            endPt:     trackPoints.at(-1),      // æ•´æ¡çº¿çš„ç»ˆç‚¹
            pointCount: trackPoints.length
        }
    };
  console.log("å·²æ›´æ–° G1_EXPORT: ", G1_EXPORT);

  // â˜… æœ€åä¸€æ­¥ï¼šåˆ·æ–°è‡ªç„¶åˆ†æ®µ JSONï¼ˆç”¨äºä¸‹è½½ & ç¼–è¾‘å™¨ï¼‰
  updateExportJson();
}
console.log("ğŸ”¥ G1_EXPORT:", window.G1_EXPORT);



// -----------------------------------------------------
// â˜…â˜…â˜…â˜…â˜… åˆ·æ–°è‡ªç„¶åˆ†æ®µ JSON â€”â€” ä¸‹è½½ JSON & ç¼–è¾‘å™¨è¯»å–éƒ½é å®ƒ
// -----------------------------------------------------
function updateExportJson() {

  if (!window.G1_EXPORT) {
    console.warn("G1_EXPORT å°šæœªç”Ÿæˆï¼Œæ— æ³•åˆ·æ–° JSON");
    return;
  }

  // =============================
  // å®‰å…¨å…œåº•ï¼šæœ€ç»ˆæƒå¨æ•°æ®æº
  // =============================
  const trackPtsSafe = window.trackPoints || [];
  const g1SegSafe    = window.g1Segments || [];
  const vegSafe      = window.vegSeg || [];
  const facSafe      = window.facilities || [];
  const weatherSafe  = window.weatherZones || [];

  // =============================
  // â­ å…œåº•é‡æ–°ç»Ÿè®¡ï¼ˆåªç”¨äº metaï¼‰
  // ä¸å½±å“ä»»ä½•æ—¢æœ‰é€»è¾‘
  // =============================
  let _dist = 0;
  let _asc = 0;
  let _desc = 0;
  let _minEle = null;
  let _maxEle = null;

  for (let i = 1; i < trackPtsSafe.length; i++) {
    const p0 = trackPtsSafe[i - 1];
    const p1 = trackPtsSafe[i];

    const d = dist(p0.lat, p0.lon, p1.lat, p1.lon);
    _dist += d;

    const gain = p1.ele - p0.ele;
    if (gain > 0) _asc += gain;
    else _desc += -gain;

    if (_minEle === null || p1.ele < _minEle) _minEle = p1.ele;
    if (_maxEle === null || p1.ele > _maxEle) _maxEle = p1.ele;
  }

  // =============================
  // å¯¼å‡º JSONï¼ˆç»“æ„ä¿æŒä¸å˜ï¼‰
  // =============================
  window._G1_EXPORT_JSON = {

    meta: {
      name: document.getElementById("routeName")?.textContent.replace("è½¨è¿¹åç§°ï¼š", "") || "",
      date: document.getElementById("dateInput")?.value || "",
      distanceKm: Number((_dist / 1000).toFixed(2)),
      ascent: Number(_asc.toFixed(1)),
      descent: Number(_desc.toFixed(1)),
      maxEle: _maxEle,
      minEle: _minEle
    },

    trackInfo: {
      mode: window._currentTrackMode,
      pointCount: trackPtsSafe.length
    },

    track: trackPtsSafe.map(p => ({
      lat: p.lat,
      lon: p.lon,
      ele: p.ele,
      cumDist: p.cumDist
    })),

    naturalSegments: g1SegSafe.map(s => ({
      id: s.id,
      startKm: s.startKm,
      endKm: s.endKm,
      deltaEle: s.deltaEle,
      slopePct: s.slopePct,
      slopeClass: s.slopeClass,
      altBand: s.altBand,
      startPt: s.startPt,
      endPt: s.endPt,
      ext: s.ext || null
    })),

    weather: weatherSafe,
    vegetation: vegSafe,
    facilities: facSafe
  };

  console.log("âœ¨ JSON å·²åˆ·æ–°:", window._G1_EXPORT_JSON);
}




//-----------------------------------------------------
// Step3ï¼šG2 åŠ¨æ€ç»“æ„ï¼ˆæŒ‰å°æ—¶ Ã— å½“å¤©é¢„æŠ¥ï¼‰
//-----------------------------------------------------
async function buildG2(){
  if(trackPoints.length<2){ alert("è¯·å…ˆè§£æè½¨è¿¹"); return; }
  const dateStr=document.getElementById("dateInput").value;
  if(!dateStr){
    alert("G2 éœ€è¦å…·ä½“å‡ºå‘æ—¥æœŸï¼ˆç”¨äºæŸ¥è¯¢å½“å¤©é€å°æ—¶å¤©æ°”ï¼‰");
    return;
  }

  const kmTotal=totalDist/1000;

  let hours;
  const withTime=trackPoints.filter(p=>p.time);
  if(withTime.length>=2){
    const t0=withTime[0].time;
    const t1=withTime[withTime.length-1].time;
    hours=(t1-t0)/3600000;
  }
  if(!hours || hours<=0){
    const avgSpeed=3.0;
    hours=kmTotal/avgSpeed;
  }
  const slotCount=Math.max(1,Math.ceil(hours));
  const slotKm=kmTotal/slotCount;

  const midIdx=Math.floor(trackPoints.length/2);
  const lat=trackPoints[midIdx].lat;
  const lon=trackPoints[midIdx].lon;

  let weatherData=null;
  let note="";

  try{
    const url=`https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&hourly=temperature_2m,apparent_temperature,precipitation,wind_speed_10m&timezone=auto&start_date=${dateStr}&end_date=${dateStr}`;
    const res=await fetch(url);
    if(res.ok){
      weatherData=await res.json();
      note="å¤©æ°”æ•°æ®æ¥æºï¼šOpen-Meteo å…è´¹å¤©æ°” APIï¼ˆé€å°æ—¶é¢„æŠ¥ï¼‰ã€‚";
    }else{
      note="æœªèƒ½æˆåŠŸè·å– Open-Meteo æ•°æ®ï¼Œä»¥ä¸‹ä¸ºç»“æ„ç¤ºä¾‹ï¼ˆä¸å«çœŸå®å¤©æ°”å€¼ï¼‰ã€‚";
    }
  }catch(e){
    note="ç½‘ç»œé”™è¯¯æˆ–æ— æ³•è®¿é—® Open-Meteoï¼Œä»¥ä¸‹ä¸ºç»“æ„ç¤ºä¾‹ï¼ˆä¸å«çœŸå®å¤©æ°”å€¼ï¼‰ã€‚";
  }

  const times = weatherData && weatherData.hourly && weatherData.hourly.time ? weatherData.hourly.time : [];
  const temp  = weatherData && weatherData.hourly ? weatherData.hourly.temperature_2m : [];
  const app   = weatherData && weatherData.hourly ? weatherData.hourly.apparent_temperature : [];
  const prec  = weatherData && weatherData.hourly ? weatherData.hourly.precipitation : [];
  const wind  = weatherData && weatherData.hourly ? weatherData.hourly.wind_speed_10m : [];

  let html=`
<h3>2. åˆ†åŒº Ã— å°æ—¶å¤©æ°”ç»“æ„</h3>
<p>${note}</p>
<p>å‡ºå‘æ—¥æœŸï¼š${dateStr}ï¼›é¢„è®¡æ€»æ—¶é•¿ â‰ˆ ${hours.toFixed(1)} å°æ—¶ï¼Œåˆ’åˆ†ä¸º ${slotCount} ä¸ªå°æ—¶æ®µã€‚</p>
<table>
<tr>
  <th>æ—¶é—´æ®µ</th><th>å¯¹åº”æœ¬åœ°æ—¶é—´</th><th>å…¬é‡ŒåŒºé—´</th><th>ä¸­ç‚¹æµ·æ‹”</th>
  <th>æ°”æ¸©ï¼ˆâ„ƒï¼‰</th><th>ä½“æ„Ÿæ¸©åº¦ï¼ˆâ„ƒï¼‰</th><th>é£é€Ÿï¼ˆm/sï¼‰</th><th>é™æ°´ï¼ˆmmï¼‰</th>
</tr>`;

  for(let i=0;i<slotCount;i++){
    const sKm=slotKm*i;
    const eKm=(i===slotCount-1)?kmTotal:slotKm*(i+1);
    const midKm=(sKm+eKm)/2;
    const pMid=interpKm(midKm);
    let timeLabel="â€”", tVal="â€”", appVal="â€”", wVal="â€”", pVal="â€”";

    if(times.length>0 && i<times.length){
      timeLabel=times[i].replace("T"," ");
      if(typeof temp[i]!=="undefined") tVal=temp[i];
      if(typeof app[i]!=="undefined")  appVal=app[i];
      if(typeof wind[i]!=="undefined") wVal=wind[i];
      if(typeof prec[i]!=="undefined") pVal=prec[i];
    }

    html+=`
<tr>
  <td>T+${i}h ~ T+${i+1}h</td>
  <td>${timeLabel}</td>
  <td>${sKm.toFixed(2)}â€“${eKm.toFixed(2)} km</td>
  <td>${Math.round(pMid.ele)} m</td>
  <td>${tVal}</td>
  <td>${appVal}</td>
  <td>${wVal}</td>
  <td>${pVal}</td>
</tr>`;
  }

  html+=`</table>
<div class="note">
è¯´æ˜ï¼šG2 ä½¿ç”¨ Open-Meteo æä¾›çš„é€å°æ—¶é¢„æŠ¥ï¼ˆæ°”æ¸©ã€ä½“æ„Ÿæ¸©åº¦ã€é£é€Ÿã€é™æ°´ï¼‰ï¼Œåæ ‡ä¸ºæ•´æ¡çº¿è·¯çš„ä¸­ç‚¹ã€‚<br>
è·¯çº¿å†…ä¸åŒæµ·æ‹”çš„æ°”å€™å·®å¼‚ï¼Œè¯·ç»“åˆ G1 ä¸­çš„å…³é”®ç‚¹å¤©æ°”ç†è§£ã€‚
</div>
`;
  document.getElementById("g2").innerHTML=html;
}

//-----------------------------------------------------
// NEWï¼šç»Ÿä¸€æ®µè½ç”Ÿæˆï¼ˆS æ®µ + 7 å¤§ç±»å†™å®æ®µè½ï¼‰
//-----------------------------------------------------
function buildUnifiedSegmentsFinal() {
  if (!trackPoints || trackPoints.length < 2) return [];

  const bp = computeRouteBreakpoints(trackPoints);   // 3æ®µæˆ–5æ®µ
  const emptySegs = buildEmptyUnifiedSegments(bp);   // S1-S3 / S1-S5

  emptySegs.forEach(seg => {
    const s = seg.startPt.cumDist / 1000;
    const e = seg.endPt.cumDist / 1000;
    seg.startKm = s;
    seg.endKm = e;
  });

  const final = emptySegs.map(seg => {
    const Sstart = seg.startKm;
    const Send   = seg.endKm;

    const geom = unified7.geomorph.find(g => g.startKm <= Sstart && g.endKm >= Send);
    const veg  = unified7.vegetation.find(v => v.startKm <= Sstart && v.endKm >= Send);
    const surf = unified7.surface.find(s => s.startKm <= Sstart && s.endKm >= Send);
    const cult = unified7.culture.find(c => c.startKm <= Sstart && c.endKm >= Send);

    const weather = (() => {
      if (!unified7.weather || unified7.weather.length === 0) return null;
      let nearest = unified7.weather[0];
      let minDiff = Math.abs(unified7.weather[0].km - Sstart);
      unified7.weather.forEach(z => {
        const d = Math.abs(z.km - Sstart);
        if (d < minDiff) {
          minDiff = d;
          nearest = z;
        }
      });
      return nearest;
    })();

    return {
      id: seg.id,
      startKm: Sstart,
      endKm: Send,
      startEle: seg.startPt.ele,
      endEle: seg.endPt.ele,

      geomorph: geom || null,
      vegetation: veg || null,
      surface: surf || null,
      culture: cult || null,
      weather: weather,

      source: "Unified7 è‡ªåŠ¨ç”Ÿæˆï¼ˆS æ®µ Ã— 7 ç±»è§„åˆ™ï¼‰"
    };
  });

  window.unified7_scenes = final;
  return final;
}

//-----------------------------------------------------
// Step5ï¼šåœºæ™¯æ®µï¼ˆç›´æ¥åŸºäº G1ï¼‰
//-----------------------------------------------------
function buildScenes(){
  if(g1Segments.length===0){
    alert("è¯·å…ˆç”Ÿæˆ G1 æŠ¥å‘Š");
    return;
  }
  let html="";
  g1Segments.forEach((s)=>{
    const title=`${s.id}ï½œ${s.slopeLabel}`;
    html+=`
<div class="scene-box">
  <h3>${title}</h3>
  <p>é‡Œç¨‹ï¼š${s.startKm.toFixed(2)}â€“${s.endKm.toFixed(2)} km</p>
  <p>é«˜åº¦å˜åŒ–ï¼š${s.deltaEle} mï¼ˆçº¦ ${s.slopePct}%ï¼‰</p>
  <p>åœ°è²Œ / æ¤è¢«ï¼š${s.geom}ï¼ˆ${s.altBand}ï¼‰</p>
  <p>èµ·ç‚¹ï¼š${fmtCoord(s.startPt)} ï½œ <a href="${mapUrl(s.startPt)}" target="_blank">åœ°å›¾</a></p>
  <p>ç»ˆç‚¹ï¼š${fmtCoord(s.endPt)} ï½œ <a href="${mapUrl(s.endPt)}" target="_blank">åœ°å›¾</a></p>
  <p class="note">ç®—æ³•æ¥æºï¼šåŒ G1ï¼ˆå¡åº¦ + æµ·æ‹”å¸¦ç»„åˆï¼‰ï¼Œä»…ä½œåœºæ™¯èŠ‚ç‚¹å»ºè®®ï¼Œé¢†é˜Ÿå¯åœ¨åå°é‡å‘½åä¸è¡¥å……æ•…äº‹ã€‚</p>
</div>`;
  });
  document.getElementById("scenes").innerHTML=html;
}

//-----------------------------------------------------
// Step 6ï¼šæŠŠ unified7_scenes è½¬æˆ â€œèŠ‚ç‚¹æ°”æ³¡ JSONâ€
//-----------------------------------------------------
function buildBubbleNodes() {
  const scenes = window.unified7_scenes;
  if (!scenes || scenes.length === 0) {
    alert("è¯·å…ˆè¿è¡Œ buildUnifiedSegmentsFinal()");
    return null;
  }

  const bubbles = scenes.map(s => {
    return {
      id: s.id,
      startKm: s.startKm,
      endKm: s.endKm,
      startEle: s.startEle,
      endEle: s.endEle,

      weather: s.weather ? {
        temp: s.weather.temp,
        humidity: s.weather.humidity,
        uv: s.weather.uv,
        feelsLike: s.weather.feelsLike,
        wind: s.weather.wind,
        source: "Open-Meteo"
      } : null,

      geomorph: s.geomorph ? {
        type: s.geomorph.type,
        desc: s.geomorph.desc,
        source: s.geomorph.source || "DEM + åœ°è²Œæ¨æ–­"
      } : null,

      vegetation: s.vegetation ? {
        zone: s.vegetation.zone,
        desc: s.vegetation.desc,
        source: s.vegetation.source || "WWF Ecoregion"
      } : null,

      surface: s.surface ? {
        type: s.surface.type,
        desc: s.surface.desc,
        source: "OSM Surface"
      } : null,

      culture: s.culture ? {
        poi: s.culture.poi,
        desc: s.culture.desc,
        source: "Wikidata"
      } : null,

      summary: s.summary || null,
      bubbleType: "segment",
      version: "v1.0"
    };
  });

  window.routeBubbles = bubbles;
  console.log("æ°”æ³¡èŠ‚ç‚¹å·²ç”Ÿæˆï¼š", bubbles);
  return bubbles;
}

//-----------------------------------------------------
// å…¨å±€ï¼šè‡ªç„¶åˆ†æ®µå‡½æ•° + è‹¥å¹²åˆ†ç±»å‡½æ•°
//-----------------------------------------------------
function naturalSplit(trackPoints, getType) {
  if (!trackPoints || trackPoints.length === 0) return [];

  const result = [];
  let startIdx = 0;
  let lastType = getType(trackPoints[0], 0);

  for (let i = 1; i < trackPoints.length; i++) {
    const t = getType(trackPoints[i], i);
    if (t !== lastType) {
      const sPt = trackPoints[startIdx];
      const ePt = trackPoints[i - 1];
      result.push({
        type: lastType,
        startIdx: startIdx,
        endIdx: i - 1,
        startPt: sPt,
        endPt: ePt,
        startKm: sPt.cumDist / 1000,
        endKm: ePt.cumDist / 1000
      });
      startIdx = i;
      lastType = t;
    }
  }

  const sPt = trackPoints[startIdx];
  const ePt = trackPoints[trackPoints.length - 1];
  result.push({
    type: lastType,
    startIdx: startIdx,
    endIdx: trackPoints.length - 1,
    startPt: sPt,
    endPt: ePt,
    startKm: sPt.cumDist / 1000,
    endKm: ePt.cumDist / 1000
  });

  return result;
}

function getTerrainType(prev, pt) {
  if (!prev) return "æœªçŸ¥";
  const distM = Math.max(1, pt.cumDist - prev.cumDist);
  const slopePct = (pt.ele - prev.ele) / distM * 100;

  if (slopePct > 15) return "é™¡ä¸Š";
  if (slopePct > 8)  return "æŒç»­ä¸Š";
  if (slopePct > 3)  return "ç¼“ä¸Š";
  if (slopePct > -3) return "å¹³ç¼“";
  if (slopePct > -8) return "ç¼“ä¸‹";
  if (slopePct > -15)return "æŒç»­ä¸‹";
  return "é™¡ä¸‹";
}

function getVegetationType(pt) {
  return altBandLabel(pt.ele);
}

function getLandformType(prev, pt) {
  if (!prev) return "æœªçŸ¥";
  const distKm = Math.max(0.001, (pt.cumDist - prev.cumDist) / 1000);
  const delta = pt.ele - prev.ele;
  const slope = classifySlope(delta, distKm);
  const meanEle = (pt.ele + prev.ele) / 2;
  return geomorphDesc(meanEle, slope.label);
}

function getSurfaceType(pt) {
  return pt.surfaceType || "æœªçŸ¥è·¯é¢";
}

function splitFacilities(trackPoints) {
  const arr = [];
  for (let i = 0; i < trackPoints.length; i += 80) {
    arr.push({
      type: "è§‚æ™¯ç‚¹",
      km: trackPoints[i].cumDist / 1000,
      ele: trackPoints[i].ele,
      hint: "è§†é‡è‰¯å¥½ï¼Œå¯çŸ­æš‚åœç•™"
    });
  }
  return arr;
}

function splitCultural(trackPoints) {
  const arr = [];
  for (let i = 0; i < trackPoints.length; i += 120) {
    arr.push({
      type: "æ–‡åŒ–èŠ‚ç‚¹",
      km: trackPoints[i].cumDist / 1000,
      ele: trackPoints[i].ele,
      hint: "å¯ç»“åˆå½“åœ°å†å²/åœ°ç†å™äº‹"
    });
  }
  return arr;
}
// === éšè— 2.3ï½6 æ‰€æœ‰æ®µè½ï¼Œä½†ä¿ç•™ 2.1ã€2.2ã€7 ===
function hideUnwantedSections() {
    const g1 = document.getElementById("g1");
    if (!g1) return;

    const children = [...g1.children];
    let hide = false;

    children.forEach(el => {
        if (el.innerText.trim().startsWith("2.3")) hide = true;
        if (el.innerText.trim().startsWith("7.")) hide = false;
        if (hide) el.style.display = "none";
    });
}

// åœ¨ç”Ÿæˆ G1 æŠ¥å‘Šåæ‰§è¡Œéšè—
const oldBuildG1 = buildG1;
buildG1 = async function() {
    await oldBuildG1();
    hideUnwantedSections();
};
</script>   <!-- â†â†â† è¿™æ˜¯ä½ åŸæœ‰ JS çš„ç»“æŸæ ‡ç­¾ï¼Œå¿…é¡»ä¿ç•™ -->

<!-- â˜… å¯¼å‡º JSON + è¿›å…¥ç¼–è¾‘å™¨ + ä¸‹è½½ JSONï¼ˆæœ€ç»ˆç¨³å®šç‰ˆï¼‰ -->
<script>
/* ============================================================
   â˜… G1 å¯¼å‡ºã€è¿›å…¥ç¼–è¾‘å™¨ã€ä¸‹è½½ JSON â€”â€” æœ€ç»ˆç¨³å®šç‰ˆæœ¬
   ============================================================ */


// ==========================
// è¿›å…¥äººå·¥ç¼–è¾‘å™¨ï¼ˆä½¿ç”¨ G1_EXPORTï¼‰
// ==========================
document.getElementById("openEditorBtn").onclick = () => {

  // å¿…é¡»æœ‰ G1_EXPORT æ‰èƒ½è¿›å…¥ç¼–è¾‘å™¨
  if (!window.G1_EXPORT || !G1_EXPORT.profile || !G1_EXPORT.segments) {
    alert("è¯·å…ˆç‚¹å‡»ã€ç”Ÿæˆè‡ªç„¶åˆ†æ®µã€");
    return;
  }

  // â€”â€” è€ç¼–è¾‘å™¨ä½¿ç”¨çš„æ•°æ®ç»“æ„ â€”â€”ï¼ˆä¿æŒä½ çš„åŸè®¾è®¡ï¼‰
  localStorage.setItem("G1_FROM_ANALYZER", JSON.stringify({
  meta:         G1_EXPORT.meta || {},   // â­ å…³é”®ï¼šæŠŠç»Ÿè®¡æ•°æ®å¸¦è¿‡å»
  profile:      G1_EXPORT.profile,
  segments:     G1_EXPORT.segments,
  weatherNodes: G1_EXPORT.weatherNodes,
  manualScenes: G1_EXPORT.manualScenes || []
}));

  // â€”â€” æ–°ç»“æ„ï¼ˆè‡ªç„¶åˆ†æ®µ JSONï¼‰å¦‚æœç”Ÿæˆè¿‡ï¼Œåˆ™å†™å…¥ â€”â€” 
  if (window._G1_EXPORT_JSON) {
    localStorage.setItem("G1_NATURAL_JSON", JSON.stringify(window._G1_EXPORT_JSON));
  }

  // è·³è½¬ç¼–è¾‘å™¨
  window.location.href = "manual_G1_editor.html";
};



// ==========================
// ä¸‹è½½ JSONï¼ˆä½¿ç”¨ _G1_EXPORT_JSONï¼‰
// ==========================
document.getElementById("downloadJsonBtn").onclick = () => {
  if (!window._G1_EXPORT_JSON) {
    alert("è¯·å…ˆç”Ÿæˆè‡ªç„¶åˆ†æ®µ");
    return;
  }

  const jsonStr = JSON.stringify(window._G1_EXPORT_JSON, null, 2);

  const blob = new Blob([jsonStr], { type: "application/json" });
  const url = URL.createObjectURL(blob);

  const a = document.createElement("a");
  a.href = url;
  a.download = "G1_natural_segments.json";  
  a.click();

  URL.revokeObjectURL(url);
};


// ========================
// 2. Level-2 æ·±åº¦æ¸…æ´—ï¼ˆåœ¨ postProcessTrack ä¹‹åï¼Œç”¨äºè¿›ä¸€æ­¥æ¶ˆé™¤å°–åˆºï¼‰
//    è¾“å…¥ï¼štrackPointsï¼ˆå¯¹è±¡æ•°ç»„ {lat,lon,ele,time,...}ï¼‰
//    è¾“å‡ºï¼šæ–°çš„ points æ•°ç»„
// ========================
function cleanTrackLevel2(points) {
  if (!Array.isArray(points) || points.length < 3) return points;

  const MAX_SPEED      = 7.5;   // m/s
  const MAX_ACCEL      = 3.5;   // m/sÂ²
  const MAX_DIR_CHANGE = 120;   // æœ€å¤§è½¬å‘è§’
  const WINDOW         = 5;

  function distance(a, b) {
    const R    = 6371000;
    const dLat = (b.lat - a.lat) * Math.PI / 180;
    const dLon = (b.lon - a.lon) * Math.PI / 180;
    const lat1 = a.lat * Math.PI / 180;
    const lat2 = b.lat * Math.PI / 180;
    const s =
      Math.sin(dLat/2)**2 +
      Math.cos(lat1)*Math.cos(lat2)*Math.sin(dLon/2)**2;
    return 2 * R * Math.asin(Math.sqrt(s));
  }

  function direction(a, b) {
    const y = Math.sin((b.lon - a.lon) * Math.PI / 180) * Math.cos(b.lat * Math.PI / 180);
    const x = Math.cos(a.lat*Math.PI/180)*Math.sin(b.lat*Math.PI/180) -
              Math.sin(a.lat*Math.PI/180)*Math.cos(b.lat*Math.PI/180)*
              Math.cos((b.lon - a.lon)*Math.PI/180);
    return Math.atan2(y, x) * 180 / Math.PI;
  }

  const cleaned = [points[0]];

  for (let i = 1; i < points.length - 1; i++) {
    const p0 = cleaned[cleaned.length - 1];
    const p1 = points[i];
    const p2 = points[i + 1];

    const dt1 = (new Date(p1.time) - new Date(p0.time)) / 1000;
    const dt2 = (new Date(p2.time) - new Date(p1.time)) / 1000;
    if (dt1 <= 0 || dt2 <= 0) continue;

    const d1 = distance(p0, p1);
    const d2 = distance(p1, p2);

    const v1 = d1 / dt1;
    const v2 = d2 / dt2;

    const dir1 = direction(p0, p1);
    const dir2 = direction(p1, p2);
    let dirDiff = Math.abs(dir2 - dir1);
    if (dirDiff > 180) dirDiff = 360 - dirDiff;

    const accel = (v2 - v1) / dt2;

    if (v1 > MAX_SPEED || v2 > MAX_SPEED) continue;
    if (accel > MAX_ACCEL) continue;
    if (dirDiff > MAX_DIR_CHANGE) continue;

    cleaned.push(p1);
  }

  cleaned.push(points[points.length - 1]);

  // ç®€å•å¹³æ»‘ä¸€ä¸‹ï¼ˆå’Œä½ ä¹‹å‰ç‰ˆæœ¬ä¸€æ ·ï¼‰
  const smoothed = cleaned.map((p, i) => {
    const start = Math.max(0, i - WINDOW);
    const end   = Math.min(cleaned.length - 1, i + WINDOW);
    const slice = cleaned.slice(start, end + 1);
    return {
      ...p,
      lat: slice.reduce((s,v)=>s+v.lat,0)/slice.length,
      lon: slice.reduce((s,v)=>s+v.lon,0)/slice.length,
      ele: slice.reduce((s,v)=>s+v.ele,0)/slice.length
    };
  });

  return smoothed;
}

/* ========================
 * Level-3ï¼šæ·±åº¦æ¸…æ´—ï¼ˆæç«¯ç›´çº¿è·³ç‚¹è¿‡æ»¤ï¼‰
 * ======================== */
function deepCleanTrack(latlngs) {
  if (!Array.isArray(latlngs) || latlngs.length < 5) return latlngs;

  function distanceKm(lat1, lon1, lat2, lon2) {
    const R = 6371;
    const dLat = (lat2 - lat1) * Math.PI / 180;
    const dLon = (lon2 - lon1) * Math.PI / 180;
    const rLat1 = lat1 * Math.PI / 180;
    const rLat2 = lat2 * Math.PI / 180;

    const a =
      Math.sin(dLat / 2) ** 2 +
      Math.cos(rLat1) * Math.cos(rLat2) *
      Math.sin(dLon / 2) ** 2;

    return 2 * R * Math.asin(Math.sqrt(a));
  }

  const clean = [latlngs[0]];

  for (let i = 1; i < latlngs.length - 1; i++) {
    const p0 = clean[clean.length - 1];
    const p1 = latlngs[i];
    const p2 = latlngs[i + 1];

    const d01 = distanceKm(p0[0], p0[1], p1[0], p1[1]);
    const d12 = distanceKm(p1[0], p1[1], p2[0], p2[1]);
    const d02 = distanceKm(p0[0], p0[1], p2[0], p2[1]);

    if (d02 < d01 + d12 * 1.5) {
      clean.push(p1);
    }
  }

  clean.push(latlngs[latlngs.length - 1]);
  return clean;
}
/* ========================
 * æ ¹æ®ä¸€ç»„ç‚¹ï¼Œæ›´æ–°å…¨å±€ç»Ÿè®¡ï¼ˆtrackPoints + totalDist ç­‰ï¼‰
 * ======================== */
function applyTrackStatsFrom(points){
  if (!Array.isArray(points) || points.length < 2) return;

  const stats = recomputeStats(points);
  trackPoints = stats.points;
  totalDist   = stats.totalDist;
  ascent      = stats.ascent;
  descent     = stats.descent;
  minEle      = stats.minEle;
  maxEle      = stats.maxEle;
}

/* ========================
 * æŠŠ L2 æŠ˜çº¿ï¼ˆ[lat, lon]ï¼‰è½¬æ¢æˆå¸¦ ele/cumDist çš„å¯¹è±¡æ•°ç»„
 * åŸºäº Level-1 çš„ç‚¹åšåŒ¹é…
 * ======================== */
function buildL2TrackPoints(){
  if (!window.G1_L2_TRACK || !window.G1_L2_TRACK.length) return [];
  if (!Array.isArray(l1TrackPoints) || !l1TrackPoints.length) return [];

  const index = new Map();
  l1TrackPoints.forEach(p => {
    const key = `${p.lat.toFixed(6)},${p.lon.toFixed(6)}`;
    index.set(key, p);
  });

  const out = [];

  window.G1_L2_TRACK.forEach(pair => {
    const lat = pair[0];
    const lon = pair[1];
    const key = `${lat.toFixed(6)},${lon.toFixed(6)}`;
    const base = index.get(key);

    if (base) {
      out.push({ ...base });
    } else {
      const last = out[out.length - 1];
      out.push({
        lat,
        lon,
        ele: last ? last.ele : 0,
        time: null,
        cumDist: 0
      });
    }
  });

  return out;
}

/* ========================
 * ç»Ÿä¸€åˆ‡æ¢å½“å‰è½¨è¿¹æ¨¡å¼
 * mode: "raw" | "l1" | "l2"
 * ======================== */
function setActiveTrackMode(mode){
  window._currentTrackMode = mode;

  // 1ï¼‰æŒ‰é’®é«˜äº®
  const idMap = {
    raw: "btnShowRaw",
    l1:  "btnShowL1",
    l2:  "btnShowL2"
  };
  const activeId = idMap[mode];

  ["btnShowRaw","btnShowL1","btnShowL2"].forEach(id => {
    const btn = document.getElementById(id);
    if (!btn) return;
    if (id === activeId) btn.classList.add("clean-selected");
    else btn.classList.remove("clean-selected");
  });

  // 2ï¼‰åˆ‡æ¢ç”¨äºåç»­åˆ†æçš„è½¨è¿¹æ•°æ®
  if (mode === "raw" && rawTrackPoints.length >= 2) {
    applyTrackStatsFrom(rawTrackPoints);
  } else if (mode === "l2" && window.G1_L2_TRACK && window.G1_L2_TRACK.length) {
    if (!l2TrackPoints.length) {
      l2TrackPoints = buildL2TrackPoints();
    }
    if (l2TrackPoints.length >= 2) {
      applyTrackStatsFrom(l2TrackPoints);
    }
  } else {
    // é»˜è®¤ç”¨ Level-1
    if (l1TrackPoints.length >= 2) {
      applyTrackStatsFrom(l1TrackPoints);
    }
  }

  // 3ï¼‰æ›´æ–°ç‚¹æ•°æ˜¾ç¤º
  updatePointStats();
}

/* è¾…åŠ©ï¼šæŠŠå½“å‰æ¨¡å¼è½¬ä¸ºä¸­æ–‡è¯´æ˜ */
function getActiveTrackModeText(){
  const mode = window._currentTrackMode || "l1";
  if (mode === "raw") return "å½“å‰ç”¨äºåç»­åˆ†æï¼šåŸå§‹è½¨è¿¹";
  if (mode === "l2")  return "å½“å‰ç”¨äºåç»­åˆ†æï¼šLevel-2 æ·±åº¦æ¸…æ´—è½¨è¿¹";
  return "å½“å‰ç”¨äºåç»­åˆ†æï¼šLevel-1 æ¸…æ´—è½¨è¿¹";
}
/* ========================
 * ç‚¹æ•°æ˜¾ç¤º + å½“å‰è½¨è¿¹æ¨¡å¼
 * ======================== */
function updatePointStats() {
  const box = document.getElementById("pointStats");
  if (!box) return;

  const raw = window.G1_RAW_TRACK?.length || 0;
  const l1  = window.G1_CLEAN_TRACK?.length || 0;
  const l2  = window.G1_L2_TRACK?.length || 0;

  const modeText = getActiveTrackModeText();

  box.innerHTML = `
    <div style="margin-bottom:4px;"><b>${modeText}</b></div>
    åŸå§‹ç‚¹æ•°ï¼š${raw} ä¸ªã€€
    æ¸…æ´—åç‚¹æ•°ï¼š${l1} ä¸ªã€€
    æ·±åº¦æ¸…æ´—ç‚¹æ•°ï¼š${l2} ä¸ª
  `;
}


/* ========================
 * è½¨è¿¹é¢„è§ˆåœ°å›¾ï¼ˆç»Ÿä¸€æ¨¡å¼ï¼‰
 * ======================== */
let previewMap = null;
let previewLineLayer = null;

function initPreviewMap() {
  if (previewMap) return;
  previewMap = L.map("trackMap", {
    zoomControl: false,
    attributionControl: false
  }).setView([30,110],4);

  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
    maxZoom: 19
  }).addTo(previewMap);
}

function drawPreviewLine(latlngs, color) {
  if (!Array.isArray(latlngs) || !latlngs.length) return;

  initPreviewMap();

  if (previewLineLayer) previewMap.removeLayer(previewLineLayer);

  previewLineLayer = L.polyline(latlngs, {
    color: color,
    weight: 3,
    opacity: 0.9
  }).addTo(previewMap);

  previewMap.fitBounds(previewLineLayer.getBounds(), { padding: [20, 20] });
}

function previewRawTrack(latlngs)    { drawPreviewLine(latlngs, "#ff3333"); }
function previewCleanedTrack(latlngs){ drawPreviewLine(latlngs, "#009966"); }
function previewL2Track(latlngs)     { drawPreviewLine(latlngs, "#0066ff"); }

document.addEventListener("DOMContentLoaded", () => {
  // â˜…â˜…â˜… é»˜è®¤æ—¥æœŸï¼ˆæ˜å¤©ï¼‰â€”â€”åŠ å›è¿™ä¸€æ®µ â˜…â˜…â˜…
  const d = new Date();
  d.setDate(d.getDate() + 1);
  const dateInput = document.getElementById("dateInput");
  if (dateInput) {
    dateInput.value = d.toISOString().split("T")[0];
  }

  // åŸå§‹è½¨è¿¹æŒ‰é’®
  const btnRaw = document.getElementById("btnShowRaw");
  if (btnRaw) {
    btnRaw.onclick = () => {
      if (!window.G1_RAW_TRACK) {
        alert("åŸå§‹è½¨è¿¹æœªåŠ è½½");
        return;
      }
      previewRawTrack(window.G1_RAW_TRACK);
      setActiveTrackMode("raw");
    };
  }

  // Level-1 æ¸…æ´—æŒ‰é’®
  const btnL1 = document.getElementById("btnShowL1");
  if (btnL1) {
    btnL1.onclick = () => {
      if (!window.G1_CLEAN_TRACK) {
        alert("å°šæœªæ‰§è¡Œ Level-1 æ¸…æ´—");
        return;
      }
      previewCleanedTrack(window.G1_CLEAN_TRACK);
      setActiveTrackMode("l1");
    };
  }

  // Level-2 æ·±åº¦æ¸…æ´—æŒ‰é’®
  const btnL2 = document.getElementById("btnShowL2");
  if (btnL2) {
    btnL2.onclick = () => {
      if (!window.G1_CLEAN_TRACK) {
        alert("è¯·å…ˆå®Œæˆ Level-1 æ¸…æ´—");
        return;
      }

      if (!window.G1_L2_TRACK) {
        // åªåšå½¢çŠ¶æ·±åº¦æ¸…æ´—
        window.G1_L2_TRACK = deepCleanTrack(window.G1_CLEAN_TRACK);
      }

      if (!window.G1_L2_TRACK?.length) {
        alert("Level-2 è½¨è¿¹ä¸ºç©º");
        return;
      }

      previewL2Track(window.G1_L2_TRACK);
      setActiveTrackMode("l2");
    };
  }
});

//-----------------------------------------------------
// â˜…â˜…â˜…â˜…â˜… æœ€ç»ˆç”Ÿæˆè‡ªç„¶åˆ†æ®µ JSONï¼ˆä¼˜è´¨è½¨è¿¹ JSONï¼‰
//-----------------------------------------------------
function updateExportJson() {
  window._G1_EXPORT_JSON = {
    meta: {
      name: document.getElementById("routeName").textContent.replace("è½¨è¿¹åç§°ï¼š", ""),
      date: document.getElementById("dateInput").value,
      distanceKm: (totalDist / 1000).toFixed(2),
      ascent,
      descent,
      maxEle,
      minEle
    },

    // å½“å‰è½¨è¿¹æ¨¡å¼ï¼šraw / l1 / l2
    trackInfo: {
      mode: window._currentTrackMode,
      pointCount: trackPoints.length
    },

    // è½¨è¿¹ç‚¹ï¼ˆå¹²å‡€è½¨è¿¹ï¼‰
    track: trackPoints.map(p => ({
      lat: p.lat,
      lon: p.lon,
      ele: p.ele,
      cumDist: p.cumDist
    })),

    // åœ°å½¢è‡ªç„¶æ®µï¼ˆå« extï¼‰
    naturalSegments: g1Segments.map(s => ({
      id: s.id,
      startKm: s.startKm,
      endKm: s.endKm,
      deltaEle: s.deltaEle,
      slopePct: s.slopePct,
      slopeClass: s.slopeClass,
      altBand: s.altBand,
      geom: s.geom,
      startPt: { lat: s.startPt.lat, lon: s.startPt.lon, ele: s.startPt.ele },
      endPt:   { lat: s.endPt.lat,   lon: s.endPt.lon,   ele: s.endPt.ele },
      ext: s.ext || null
    })),

    // å¤©æ°”èŠ‚ç‚¹ & æ¤è¢«æ®µ & è®¾æ–½ï¼ˆåä¸¤è€…æ²¡æœ‰å°±ç©ºæ•°ç»„ï¼‰
    weather: weatherZones || [],
    vegetation: vegSeg || [],
    facilities: facilities || []
  };

  console.log("â­â­ G1 JSON ç”Ÿæˆå®Œæˆ â†’ window._G1_EXPORT_JSON", window._G1_EXPORT_JSON);
}


</script>

</body>
</html>
